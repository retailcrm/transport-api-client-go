// Package transport_api_client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package transport_api_client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Transport_tokenScopes = "transport_token.Scopes"
)

// Defines values for Boolean.
const (
	BooleanFalse Boolean = "false"
	BooleanN0    Boolean = "0"
	BooleanN1    Boolean = "1"
	BooleanTrue  Boolean = "true"
)

// EnumValues returns all valid values for Boolean.
func (Boolean) EnumValues() []string {
	return []string{
		string(BooleanFalse),
		string(BooleanN0),
		string(BooleanN1),
		string(BooleanTrue),
	}
}

// Validate validates the value of Boolean.
func (v Boolean) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for Boolean: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for Boolean.
func (v *Boolean) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = Boolean(s)
	return nil
}

// Defines values for ChannelFeature.
const (
	ChannelFeatureBoth    ChannelFeature = "both"
	ChannelFeatureNone    ChannelFeature = "none"
	ChannelFeatureReceive ChannelFeature = "receive"
	ChannelFeatureSend    ChannelFeature = "send"
)

// EnumValues returns all valid values for ChannelFeature.
func (ChannelFeature) EnumValues() []string {
	return []string{
		string(ChannelFeatureBoth),
		string(ChannelFeatureNone),
		string(ChannelFeatureReceive),
		string(ChannelFeatureSend),
	}
}

// Validate validates the value of ChannelFeature.
func (v ChannelFeature) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ChannelFeature: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ChannelFeature.
func (v *ChannelFeature) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ChannelFeature(s)
	return nil
}

// Defines values for ChannelType.
const (
	ChannelTypeAvito         ChannelType = "avito"
	ChannelTypeConsultant    ChannelType = "consultant"
	ChannelTypeCustom        ChannelType = "custom"
	ChannelTypeDrom          ChannelType = "drom"
	ChannelTypeFbmessenger   ChannelType = "fbmessenger"
	ChannelTypeInstagram     ChannelType = "instagram"
	ChannelTypeMax           ChannelType = "max"
	ChannelTypeMegaMarket    ChannelType = "mega_market"
	ChannelTypeOdnoklassniki ChannelType = "odnoklassniki"
	ChannelTypeOzon          ChannelType = "ozon"
	ChannelTypeSkype         ChannelType = "skype"
	ChannelTypeTelegram      ChannelType = "telegram"
	ChannelTypeViber         ChannelType = "viber"
	ChannelTypeVk            ChannelType = "vk"
	ChannelTypeWhatsapp      ChannelType = "whatsapp"
	ChannelTypeWildberries   ChannelType = "wildberries"
	ChannelTypeYandexChat    ChannelType = "yandex_chat"
	ChannelTypeYandexMarket  ChannelType = "yandex_market"
	ChannelTypeYoula         ChannelType = "youla"
)

// EnumValues returns all valid values for ChannelType.
func (ChannelType) EnumValues() []string {
	return []string{
		string(ChannelTypeAvito),
		string(ChannelTypeConsultant),
		string(ChannelTypeCustom),
		string(ChannelTypeDrom),
		string(ChannelTypeFbmessenger),
		string(ChannelTypeInstagram),
		string(ChannelTypeMax),
		string(ChannelTypeMegaMarket),
		string(ChannelTypeOdnoklassniki),
		string(ChannelTypeOzon),
		string(ChannelTypeSkype),
		string(ChannelTypeTelegram),
		string(ChannelTypeViber),
		string(ChannelTypeVk),
		string(ChannelTypeWhatsapp),
		string(ChannelTypeWildberries),
		string(ChannelTypeYandexChat),
		string(ChannelTypeYandexMarket),
		string(ChannelTypeYoula),
	}
}

// Validate validates the value of ChannelType.
func (v ChannelType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for ChannelType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for ChannelType.
func (v *ChannelType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = ChannelType(s)
	return nil
}

// Defines values for CustomerExternalId.
const (
	CustomerExternalIdAny   CustomerExternalId = "any"
	CustomerExternalIdPhone CustomerExternalId = "phone"
)

// EnumValues returns all valid values for CustomerExternalId.
func (CustomerExternalId) EnumValues() []string {
	return []string{
		string(CustomerExternalIdAny),
		string(CustomerExternalIdPhone),
	}
}

// Validate validates the value of CustomerExternalId.
func (v CustomerExternalId) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for CustomerExternalId: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for CustomerExternalId.
func (v *CustomerExternalId) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = CustomerExternalId(s)
	return nil
}

// Defines values for FileType.
const (
	FileTypeAudio FileType = "audio"
	FileTypeFile  FileType = "file"
	FileTypeImage FileType = "image"
	FileTypeNone  FileType = "none"
	FileTypeVideo FileType = "video"
)

// EnumValues returns all valid values for FileType.
func (FileType) EnumValues() []string {
	return []string{
		string(FileTypeAudio),
		string(FileTypeFile),
		string(FileTypeImage),
		string(FileTypeNone),
		string(FileTypeVideo),
	}
}

// Validate validates the value of FileType.
func (v FileType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for FileType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for FileType.
func (v *FileType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = FileType(s)
	return nil
}

// Defines values for MessageAction.
const (
	MessageActionDelete MessageAction = "delete"
	MessageActionEdit   MessageAction = "edit"
	MessageActionQuote  MessageAction = "quote"
)

// EnumValues returns all valid values for MessageAction.
func (MessageAction) EnumValues() []string {
	return []string{
		string(MessageActionDelete),
		string(MessageActionEdit),
		string(MessageActionQuote),
	}
}

// Validate validates the value of MessageAction.
func (v MessageAction) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageAction: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageAction.
func (v *MessageAction) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageAction(s)
	return nil
}

// Defines values for MessageErrorCode.
const (
	MessageErrorCodeAccessRestricted  MessageErrorCode = "access_restricted"
	MessageErrorCodeAsyncSendTimeout  MessageErrorCode = "async_send_timeout"
	MessageErrorCodeCustomerNotExists MessageErrorCode = "customer_not_exists"
	MessageErrorCodeGeneral           MessageErrorCode = "general"
	MessageErrorCodeMalformedResponse MessageErrorCode = "malformed_response"
	MessageErrorCodeNetworkError      MessageErrorCode = "network_error"
	MessageErrorCodeReplyTimedOut     MessageErrorCode = "reply_timed_out"
	MessageErrorCodeSpamSuspicion     MessageErrorCode = "spam_suspicion"
	MessageErrorCodeUnknown           MessageErrorCode = "unknown"
)

// EnumValues returns all valid values for MessageErrorCode.
func (MessageErrorCode) EnumValues() []string {
	return []string{
		string(MessageErrorCodeAccessRestricted),
		string(MessageErrorCodeAsyncSendTimeout),
		string(MessageErrorCodeCustomerNotExists),
		string(MessageErrorCodeGeneral),
		string(MessageErrorCodeMalformedResponse),
		string(MessageErrorCodeNetworkError),
		string(MessageErrorCodeReplyTimedOut),
		string(MessageErrorCodeSpamSuspicion),
		string(MessageErrorCodeUnknown),
	}
}

// Validate validates the value of MessageErrorCode.
func (v MessageErrorCode) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageErrorCode: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageErrorCode.
func (v *MessageErrorCode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageErrorCode(s)
	return nil
}

// Defines values for MessageOrderStatusCode.
const (
	MessageOrderStatusCodeApproval   MessageOrderStatusCode = "approval"
	MessageOrderStatusCodeAssembling MessageOrderStatusCode = "assembling"
	MessageOrderStatusCodeCancel     MessageOrderStatusCode = "cancel"
	MessageOrderStatusCodeComplete   MessageOrderStatusCode = "complete"
	MessageOrderStatusCodeDelivery   MessageOrderStatusCode = "delivery"
	MessageOrderStatusCodeNew        MessageOrderStatusCode = "new"
)

// EnumValues returns all valid values for MessageOrderStatusCode.
func (MessageOrderStatusCode) EnumValues() []string {
	return []string{
		string(MessageOrderStatusCodeApproval),
		string(MessageOrderStatusCodeAssembling),
		string(MessageOrderStatusCodeCancel),
		string(MessageOrderStatusCodeComplete),
		string(MessageOrderStatusCodeDelivery),
		string(MessageOrderStatusCodeNew),
	}
}

// Validate validates the value of MessageOrderStatusCode.
func (v MessageOrderStatusCode) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageOrderStatusCode: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageOrderStatusCode.
func (v *MessageOrderStatusCode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageOrderStatusCode(s)
	return nil
}

// Defines values for MessageScope.
const (
	MessageScopePrivate   MessageScope = "private"
	MessageScopePublic    MessageScope = "public"
	MessageScopeUndefined MessageScope = "undefined"
)

// EnumValues returns all valid values for MessageScope.
func (MessageScope) EnumValues() []string {
	return []string{
		string(MessageScopePrivate),
		string(MessageScopePublic),
		string(MessageScopeUndefined),
	}
}

// Validate validates the value of MessageScope.
func (v MessageScope) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageScope: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageScope.
func (v *MessageScope) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageScope(s)
	return nil
}

// Defines values for MessageStatus.
const (
	MessageStatusFailed    MessageStatus = "failed"
	MessageStatusReceived  MessageStatus = "received"
	MessageStatusSeen      MessageStatus = "seen"
	MessageStatusSending   MessageStatus = "sending"
	MessageStatusSent      MessageStatus = "sent"
	MessageStatusUndefined MessageStatus = "undefined"
)

// EnumValues returns all valid values for MessageStatus.
func (MessageStatus) EnumValues() []string {
	return []string{
		string(MessageStatusFailed),
		string(MessageStatusReceived),
		string(MessageStatusSeen),
		string(MessageStatusSending),
		string(MessageStatusSent),
		string(MessageStatusUndefined),
	}
}

// Validate validates the value of MessageStatus.
func (v MessageStatus) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageStatus: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageStatus.
func (v *MessageStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageStatus(s)
	return nil
}

// Defines values for MessageType.
const (
	MessageTypeAudio   MessageType = "audio"
	MessageTypeCommand MessageType = "command"
	MessageTypeFile    MessageType = "file"
	MessageTypeImage   MessageType = "image"
	MessageTypeOrder   MessageType = "order"
	MessageTypeProduct MessageType = "product"
	MessageTypeSystem  MessageType = "system"
	MessageTypeText    MessageType = "text"
)

// EnumValues returns all valid values for MessageType.
func (MessageType) EnumValues() []string {
	return []string{
		string(MessageTypeAudio),
		string(MessageTypeCommand),
		string(MessageTypeFile),
		string(MessageTypeImage),
		string(MessageTypeOrder),
		string(MessageTypeProduct),
		string(MessageTypeSystem),
		string(MessageTypeText),
	}
}

// Validate validates the value of MessageType.
func (v MessageType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for MessageType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for MessageType.
func (v *MessageType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = MessageType(s)
	return nil
}

// Defines values for Originator.
const (
	OriginatorChannel  Originator = "channel"
	OriginatorCustomer Originator = "customer"
	OriginatorUser     Originator = "user"
)

// EnumValues returns all valid values for Originator.
func (Originator) EnumValues() []string {
	return []string{
		string(OriginatorChannel),
		string(OriginatorCustomer),
		string(OriginatorUser),
	}
}

// Validate validates the value of Originator.
func (v Originator) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for Originator: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for Originator.
func (v *Originator) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = Originator(s)
	return nil
}

// Defines values for RejectReason.
const (
	RejectReasonAbusiveContent    RejectReason = "abusive_content"
	RejectReasonIncorrectCategory RejectReason = "incorrect_category"
	RejectReasonInvalidFormat     RejectReason = "invalid_format"
	RejectReasonScam              RejectReason = "scam"
)

// EnumValues returns all valid values for RejectReason.
func (RejectReason) EnumValues() []string {
	return []string{
		string(RejectReasonAbusiveContent),
		string(RejectReasonIncorrectCategory),
		string(RejectReasonInvalidFormat),
		string(RejectReasonScam),
	}
}

// Validate validates the value of RejectReason.
func (v RejectReason) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for RejectReason: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for RejectReason.
func (v *RejectReason) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = RejectReason(s)
	return nil
}

// Defines values for SendingErrorCode.
const (
	SendingErrorCodeAccessRestricted  SendingErrorCode = "access_restricted"
	SendingErrorCodeCustomerNotExists SendingErrorCode = "customer_not_exists"
	SendingErrorCodeGeneral           SendingErrorCode = "general"
	SendingErrorCodeReplyTimedOut     SendingErrorCode = "reply_timed_out"
	SendingErrorCodeSpamSuspicion     SendingErrorCode = "spam_suspicion"
)

// EnumValues returns all valid values for SendingErrorCode.
func (SendingErrorCode) EnumValues() []string {
	return []string{
		string(SendingErrorCodeAccessRestricted),
		string(SendingErrorCodeCustomerNotExists),
		string(SendingErrorCodeGeneral),
		string(SendingErrorCodeReplyTimedOut),
		string(SendingErrorCodeSpamSuspicion),
	}
}

// Validate validates the value of SendingErrorCode.
func (v SendingErrorCode) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SendingErrorCode: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SendingErrorCode.
func (v *SendingErrorCode) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SendingErrorCode(s)
	return nil
}

// Defines values for SendingPolicyAfterReplyTimeout.
const (
	SendingPolicyAfterReplyTimeoutNo       SendingPolicyAfterReplyTimeout = "no"
	SendingPolicyAfterReplyTimeoutTemplate SendingPolicyAfterReplyTimeout = "template"
)

// EnumValues returns all valid values for SendingPolicyAfterReplyTimeout.
func (SendingPolicyAfterReplyTimeout) EnumValues() []string {
	return []string{
		string(SendingPolicyAfterReplyTimeoutNo),
		string(SendingPolicyAfterReplyTimeoutTemplate),
	}
}

// Validate validates the value of SendingPolicyAfterReplyTimeout.
func (v SendingPolicyAfterReplyTimeout) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SendingPolicyAfterReplyTimeout: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SendingPolicyAfterReplyTimeout.
func (v *SendingPolicyAfterReplyTimeout) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SendingPolicyAfterReplyTimeout(s)
	return nil
}

// Defines values for SendingPolicyNewCustomer.
const (
	SendingPolicyNewCustomerNo       SendingPolicyNewCustomer = "no"
	SendingPolicyNewCustomerTemplate SendingPolicyNewCustomer = "template"
	SendingPolicyNewCustomerText     SendingPolicyNewCustomer = "text"
)

// EnumValues returns all valid values for SendingPolicyNewCustomer.
func (SendingPolicyNewCustomer) EnumValues() []string {
	return []string{
		string(SendingPolicyNewCustomerNo),
		string(SendingPolicyNewCustomerTemplate),
		string(SendingPolicyNewCustomerText),
	}
}

// Validate validates the value of SendingPolicyNewCustomer.
func (v SendingPolicyNewCustomer) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SendingPolicyNewCustomer: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SendingPolicyNewCustomer.
func (v *SendingPolicyNewCustomer) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SendingPolicyNewCustomer(s)
	return nil
}

// Defines values for SendingPolicyOutgoing.
const (
	SendingPolicyOutgoingAllowed    SendingPolicyOutgoing = "allowed"
	SendingPolicyOutgoingRestricted SendingPolicyOutgoing = "restricted"
)

// EnumValues returns all valid values for SendingPolicyOutgoing.
func (SendingPolicyOutgoing) EnumValues() []string {
	return []string{
		string(SendingPolicyOutgoingAllowed),
		string(SendingPolicyOutgoingRestricted),
	}
}

// Validate validates the value of SendingPolicyOutgoing.
func (v SendingPolicyOutgoing) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SendingPolicyOutgoing: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SendingPolicyOutgoing.
func (v *SendingPolicyOutgoing) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SendingPolicyOutgoing(s)
	return nil
}

// Defines values for SuggestionType.
const (
	SuggestionTypeEmail SuggestionType = "email"
	SuggestionTypePhone SuggestionType = "phone"
	SuggestionTypeText  SuggestionType = "text"
	SuggestionTypeUrl   SuggestionType = "url"
)

// EnumValues returns all valid values for SuggestionType.
func (SuggestionType) EnumValues() []string {
	return []string{
		string(SuggestionTypeEmail),
		string(SuggestionTypePhone),
		string(SuggestionTypeText),
		string(SuggestionTypeUrl),
	}
}

// Validate validates the value of SuggestionType.
func (v SuggestionType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SuggestionType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SuggestionType.
func (v *SuggestionType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SuggestionType(s)
	return nil
}

// Defines values for SystemAction.
const (
	SystemActionCustomerBlocked   SystemAction = "customer_blocked"
	SystemActionCustomerUnblocked SystemAction = "customer_unblocked"
	SystemActionDialogAssign      SystemAction = "dialog_assign"
	SystemActionDialogClosed      SystemAction = "dialog_closed"
	SystemActionDialogOpened      SystemAction = "dialog_opened"
	SystemActionDialogUnassign    SystemAction = "dialog_unassign"
	SystemActionUserJoined        SystemAction = "user_joined"
	SystemActionUserLeft          SystemAction = "user_left"
)

// EnumValues returns all valid values for SystemAction.
func (SystemAction) EnumValues() []string {
	return []string{
		string(SystemActionCustomerBlocked),
		string(SystemActionCustomerUnblocked),
		string(SystemActionDialogAssign),
		string(SystemActionDialogClosed),
		string(SystemActionDialogOpened),
		string(SystemActionDialogUnassign),
		string(SystemActionUserJoined),
		string(SystemActionUserLeft),
	}
}

// Validate validates the value of SystemAction.
func (v SystemAction) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for SystemAction: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for SystemAction.
func (v *SystemAction) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = SystemAction(s)
	return nil
}

// Defines values for TemplateButtonType.
const (
	TemplateButtonTypePhone TemplateButtonType = "phone"
	TemplateButtonTypePlain TemplateButtonType = "plain"
	TemplateButtonTypeUrl   TemplateButtonType = "url"
)

// EnumValues returns all valid values for TemplateButtonType.
func (TemplateButtonType) EnumValues() []string {
	return []string{
		string(TemplateButtonTypePhone),
		string(TemplateButtonTypePlain),
		string(TemplateButtonTypeUrl),
	}
}

// Validate validates the value of TemplateButtonType.
func (v TemplateButtonType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for TemplateButtonType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TemplateButtonType.
func (v *TemplateButtonType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = TemplateButtonType(s)
	return nil
}

// Defines values for TemplateHeaderContentType.
const (
	TemplateHeaderContentTypeDocument TemplateHeaderContentType = "document"
	TemplateHeaderContentTypeImage    TemplateHeaderContentType = "image"
	TemplateHeaderContentTypeText     TemplateHeaderContentType = "text"
	TemplateHeaderContentTypeVideo    TemplateHeaderContentType = "video"
)

// EnumValues returns all valid values for TemplateHeaderContentType.
func (TemplateHeaderContentType) EnumValues() []string {
	return []string{
		string(TemplateHeaderContentTypeDocument),
		string(TemplateHeaderContentTypeImage),
		string(TemplateHeaderContentTypeText),
		string(TemplateHeaderContentTypeVideo),
	}
}

// Validate validates the value of TemplateHeaderContentType.
func (v TemplateHeaderContentType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for TemplateHeaderContentType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TemplateHeaderContentType.
func (v *TemplateHeaderContentType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = TemplateHeaderContentType(s)
	return nil
}

// Defines values for TemplateItemType.
const (
	TemplateItemTypeText TemplateItemType = 1
	TemplateItemTypeVar  TemplateItemType = 2
)

// EnumValues returns all valid values for TemplateItemType.
func (TemplateItemType) EnumValues() []string {
	return []string{
		string(TemplateItemTypeText),
		string(TemplateItemTypeVar),
	}
}

// Validate validates the value of TemplateItemType.
func (v TemplateItemType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for TemplateItemType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TemplateItemType.
func (v *TemplateItemType) UnmarshalJSON(data []byte) error {
	var s uint8
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = TemplateItemType(s)
	return nil
}

// Defines values for TemplateQuality.
const (
	TemplateQualityHigh    TemplateQuality = "high"
	TemplateQualityLow     TemplateQuality = "low"
	TemplateQualityMedium  TemplateQuality = "medium"
	TemplateQualityPending TemplateQuality = "pending"
)

// EnumValues returns all valid values for TemplateQuality.
func (TemplateQuality) EnumValues() []string {
	return []string{
		string(TemplateQualityHigh),
		string(TemplateQualityLow),
		string(TemplateQualityMedium),
		string(TemplateQualityPending),
	}
}

// Validate validates the value of TemplateQuality.
func (v TemplateQuality) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for TemplateQuality: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TemplateQuality.
func (v *TemplateQuality) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = TemplateQuality(s)
	return nil
}

// Defines values for TemplateType.
const (
	TemplateTypeMedia TemplateType = "media"
	TemplateTypeText  TemplateType = "text"
)

// EnumValues returns all valid values for TemplateType.
func (TemplateType) EnumValues() []string {
	return []string{
		string(TemplateTypeMedia),
		string(TemplateTypeText),
	}
}

// Validate validates the value of TemplateType.
func (v TemplateType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for TemplateType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TemplateType.
func (v *TemplateType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = TemplateType(s)
	return nil
}

// Defines values for TemplateVarType.
const (
	TemplateVarTypeCustom    TemplateVarType = 0
	TemplateVarTypeFirstname TemplateVarType = 2
	TemplateVarTypeLastname  TemplateVarType = 3
	TemplateVarTypeName      TemplateVarType = 1
)

// EnumValues returns all valid values for TemplateVarType.
func (TemplateVarType) EnumValues() []string {
	return []string{
		string(TemplateVarTypeCustom),
		string(TemplateVarTypeFirstname),
		string(TemplateVarTypeLastname),
		string(TemplateVarTypeName),
	}
}

// Validate validates the value of TemplateVarType.
func (v TemplateVarType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for TemplateVarType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TemplateVarType.
func (v *TemplateVarType) UnmarshalJSON(data []byte) error {
	var s uint8
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = TemplateVarType(s)
	return nil
}

// Defines values for TemplateVerificationStatus.
const (
	TemplateVerificationStatusApproved TemplateVerificationStatus = "approved"
	TemplateVerificationStatusDisabled TemplateVerificationStatus = "disabled"
	TemplateVerificationStatusPaused   TemplateVerificationStatus = "paused"
	TemplateVerificationStatusPending  TemplateVerificationStatus = "pending"
	TemplateVerificationStatusRejected TemplateVerificationStatus = "rejected"
)

// EnumValues returns all valid values for TemplateVerificationStatus.
func (TemplateVerificationStatus) EnumValues() []string {
	return []string{
		string(TemplateVerificationStatusApproved),
		string(TemplateVerificationStatusDisabled),
		string(TemplateVerificationStatusPaused),
		string(TemplateVerificationStatusPending),
		string(TemplateVerificationStatusRejected),
	}
}

// Validate validates the value of TemplateVerificationStatus.
func (v TemplateVerificationStatus) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for TemplateVerificationStatus: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for TemplateVerificationStatus.
func (v *TemplateVerificationStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = TemplateVerificationStatus(s)
	return nil
}

// Defines values for UserType.
const (
	UserTypeBot      UserType = "bot"
	UserTypeChannel  UserType = "channel"
	UserTypeCustomer UserType = "customer"
	UserTypeUser     UserType = "user"
)

// EnumValues returns all valid values for UserType.
func (UserType) EnumValues() []string {
	return []string{
		string(UserTypeBot),
		string(UserTypeChannel),
		string(UserTypeCustomer),
		string(UserTypeUser),
	}
}

// Validate validates the value of UserType.
func (v UserType) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for UserType: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for UserType.
func (v *UserType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = UserType(s)
	return nil
}

// Defines values for WAChannelQuality.
const (
	WAChannelQualityHigh   WAChannelQuality = "high"
	WAChannelQualityLow    WAChannelQuality = "low"
	WAChannelQualityMedium WAChannelQuality = "medium"
)

// EnumValues returns all valid values for WAChannelQuality.
func (WAChannelQuality) EnumValues() []string {
	return []string{
		string(WAChannelQualityHigh),
		string(WAChannelQualityLow),
		string(WAChannelQualityMedium),
	}
}

// Validate validates the value of WAChannelQuality.
func (v WAChannelQuality) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for WAChannelQuality: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for WAChannelQuality.
func (v *WAChannelQuality) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = WAChannelQuality(s)
	return nil
}

// Defines values for WAChannelStatus.
const (
	WAChannelStatusConnected  WAChannelStatus = "connected"
	WAChannelStatusFlagged    WAChannelStatus = "flagged"
	WAChannelStatusOffline    WAChannelStatus = "offline"
	WAChannelStatusPending    WAChannelStatus = "pending"
	WAChannelStatusRestricted WAChannelStatus = "restricted"
)

// EnumValues returns all valid values for WAChannelStatus.
func (WAChannelStatus) EnumValues() []string {
	return []string{
		string(WAChannelStatusConnected),
		string(WAChannelStatusFlagged),
		string(WAChannelStatusOffline),
		string(WAChannelStatusPending),
		string(WAChannelStatusRestricted),
	}
}

// Validate validates the value of WAChannelStatus.
func (v WAChannelStatus) ValidateEnum() error {
	for _, value := range v.EnumValues() {
		if string(v) == value {
			return nil
		}
	}
	return fmt.Errorf("invalid value for WAChannelStatus: %v", v)
}

// UnmarshalJSON implements the json.Unmarshaler interface for WAChannelStatus.
func (v *WAChannelStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return &json.UnmarshalTypeError{Value: err.Error()}
	}

	*v = WAChannelStatus(s)
	return nil
}

// AudioMessageSetting Audio messages support
type AudioMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// MaxItemSize Maximum audio size to send
	MaxItemSize *int64 `json:"max_item_size,omitempty"`

	// MaxItemsCount Maximum number of audio attachments per message
	MaxItemsCount *int `json:"max_items_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// Boolean Boolean type
type Boolean string

// Channel Channel
type Channel struct {
	ActivatedAt   time.Time       `json:"activated_at" time_format:"2006-01-02T15:04:05.999999Z07:00"`
	CreatedAt     time.Time       `json:"created_at" time_format:"2006-01-02T15:04:05.999999Z07:00"`
	DeactivatedAt *time.Time      `json:"deactivated_at" time_format:"2006-01-02T15:04:05.999999Z07:00"`
	ExternalID    *string         `json:"external_id"`
	ID            int64           `json:"id"`
	IsActive      bool            `json:"is_active"`
	Name          *string         `json:"name"`
	Settings      ChannelSettings `json:"settings"`

	// Type Channel types
	Type      ChannelType `json:"type"`
	UpdatedAt *time.Time  `json:"updated_at" time_format:"2006-01-02T15:04:05.999999Z07:00"`
}

// ChannelFeature Support for operation with messages of the given type
type ChannelFeature string

// ChannelSettings Channel settings
type ChannelSettings struct {
	// Audio Audio messages support
	Audio AudioMessageSetting `json:"audio,omitempty"`

	// CustomerExternalId Support for external customer identifiers
	CustomerExternalId CustomerExternalId `json:"customer_external_id,omitempty"`

	// File File messages support
	File FileMessageSetting `json:"file,omitempty"`

	// Image Media messages support
	Image ImageMessageSetting `json:"image,omitempty"`

	// Order Order messages support
	Order OrderMessageSetting `json:"order,omitempty"`

	// Product Product messages support
	Product ProductMessageSetting `json:"product,omitempty"`

	// Reactions Support for working with reactions for messages
	Reactions Reactions `json:"reactions,omitempty"`

	// SendingPolicy Message sending policy
	SendingPolicy SendingPolicy `json:"sending_policy,omitempty"`

	// Status Transmitting message status information
	Status StatusSetting `json:"status,omitempty"`

	// Suggestions Support for quick response types
	Suggestions Suggestions `json:"suggestions,omitempty"`

	// Template Support for message templates
	Template TemplateSetting `json:"template,omitempty"`

	// Text Text messages support
	Text TextMessageSetting `json:"text,omitempty"`

	// Whatsapp WhatsApp channel properties
	Whatsapp *WAChannelProperties `json:"whatsapp,omitempty"`
}

// ChannelType Channel types
type ChannelType string

// Cost Represents a monetary value with its corresponding currency
type Cost struct {
	// Currency Currency code
	Currency string `binding:"required,currency" json:"currency"`

	// Value Numerical value of the cost
	Value float64 `binding:"gte=0" json:"value"`
}

// CustomerExternalId Support for external customer identifiers
type CustomerExternalId string

// EditMessageRequestMessage defines model for EditMessageRequestMessage.
type EditMessageRequestMessage struct {
	// EditedAt Date and time of last update of message
	EditedAt int64 `json:"edited_at,omitempty"`

	// ExternalID External identifier of the message
	ExternalID *string `binding:"omitempty,max=255" json:"external_id,omitempty" mod:"trim,escape"`

	// ID Message identifier in MessageGateway
	ID *int64 `json:"id,omitempty"`

	// PageLink Link to the page from which the message was sent
	PageLink *string `json:"page_link,omitempty" mod:"trim,escape"`

	// Text Message text
	Text string `binding:"required,min=1,max=65535" json:"text" mod:"trim,escape"`
}

// File defines model for File.
type File struct {
	// Url File download URL
	Url string `json:"Url,omitempty"`

	// ID UUID of the uploaded file
	ID openapi_types.UUID `json:"id"`

	// MimeType MIME file type
	MimeType string `json:"mime_type,omitempty"`

	// Size File size (in bytes)
	Size int `json:"size"`

	// Type File type
	Type FileType `json:"type"`
}

// FileBase Base file information
type FileBase struct {
	// ID UUID of the uploaded file
	ID openapi_types.UUID `json:"id"`

	// Size File size (in bytes)
	Size int `json:"size"`

	// Type File type
	Type FileType `json:"type"`
}

// FileMessageSetting File messages support
type FileMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// MaxItemSize Maximum file size to send
	MaxItemSize *int64 `json:"max_item_size,omitempty"`

	// MaxItemsCount Maximum number of file attachments per message
	MaxItemsCount *int `json:"max_items_count,omitempty"`

	// NoteMaxCharsCount Maximum number of characters in a file message annotation
	NoteMaxCharsCount *uint16 `json:"note_max_chars_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// FileType File type
type FileType string

// Histogram Sound diagram (for audio type messages only)
type Histogram = []int

// ImageMessageSetting Media messages support
type ImageMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// MaxItemSize Maximum image size to send
	MaxItemSize *int64 `json:"max_item_size,omitempty"`

	// MaxItemsCount Maximum number of media attachments per message
	MaxItemsCount *int `json:"max_items_count,omitempty"`

	// NoteMaxCharsCount Maximum number of characters in a media message annotation
	NoteMaxCharsCount *uint16 `json:"note_max_chars_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// Message defines model for Message.
type Message struct {
	// Action System action of the message (for system type messages only)
	Action SystemAction `json:"action"`

	// Actions Actions available for this message
	Actions []MessageAction `json:"actions,omitempty"`

	// ChatID Chat identifier
	ChatID int64 `json:"chat_id"`

	// Content Message text
	Content string `json:"content,omitempty"`

	// Dialog Message dialog
	Dialog *MessageDialog `json:"dialog,omitempty"`

	// Error Message error details (only for messages with status `failed`)
	Error *MessageError `json:"error,omitempty"`

	// From Details about a user
	From *UserRef `json:"from,omitempty"`

	// ID Message identifier
	ID int64 `json:"id"`

	// IsEdit Message editing indicator
	IsEdit bool `json:"is_edit"`

	// IsRead Message read indicator
	IsRead bool          `json:"is_read"`
	Items  []MessageFile `json:"items,omitempty"`

	// Note Media data annotation (for media message)
	Note string `json:"note,omitempty"`

	// Order Represents the details of an order within a message
	Order *MessageOrder `json:"order,omitempty"`

	// Product Describes a product mentioned in a message
	Product *MessageProduct `json:"product,omitempty"`

	// Quote Quoted message
	Quote *QuoteMessage `json:"quote,omitempty"`

	// Responsible Details about a user
	Responsible *UserRef `json:"responsible,omitempty"`

	// Scope Message scope
	Scope MessageScope `json:"scope"`

	// Status Message status
	Status MessageStatus `json:"status"`

	// Time Message creation time
	Time time.Time `json:"time"`

	// TransportAttachments Transport attachments
	TransportAttachments *MessageTransportAttachments `json:"transport_attachments,omitempty"`

	// Type Message type
	Type MessageType `json:"type"`

	// User Details about a user
	User *UserRef `json:"user,omitempty"`
}

// MessageAction Defines possible actions that can be performed on a message
type MessageAction string

// MessageDialog Message dialog
type MessageDialog struct {
	// ID Dialog identifier
	ID int64 `json:"id"`
}

// MessageError Message error details (only for messages with status `failed`)
type MessageError struct {
	Code MessageErrorCode `binding:"enum-valid" json:"code"`

	// Message Text description of error
	Message string `json:"message,omitempty"`
}

// MessageErrorCode Message error code
type MessageErrorCode string

// MessageFile Attached message file
type MessageFile struct {
	// Caption Text description of the media attachment
	Caption string `json:"caption,omitempty"`

	// Duration Audio recording duration (for audio type messages only)
	Duration int `json:"duration,omitempty"`

	// Height Image height in pixels (for image type messages only)
	Height    int       `json:"height,omitempty"`
	Histogram Histogram `json:"histogram,omitempty"`

	// ID UUID of the attached file
	ID   openapi_types.UUID `json:"id,omitempty"`
	Kind FileType           `json:"kind,omitempty"`

	// PreviewURL URL for previewing or downloading the file
	PreviewURL string `json:"preview_url,omitempty"`

	// Size Attachment size (in bytes)
	Size int `json:"size,omitempty"`

	// Transcription Transcription of the uploaded file
	Transcription string `json:"transcription,omitempty"`

	// Type Attachment type
	Type string `json:"type,omitempty"`

	// Width Image width in pixels (for image type messages only)
	Width int `json:"width,omitempty"`
}

// MessageIdentifier Message identifier
type MessageIdentifier struct {
	// ExternalID External identifier of the message
	ExternalID *string `binding:"omitempty,max=255" json:"external_id,omitempty" mod:"trim,escape"`

	// ID Message identifier in MessageGateway
	ID *int64 `json:"id,omitempty"`
}

// MessageOrder Represents the details of an order within a message
type MessageOrder struct {
	// Cost Represents a monetary value with its corresponding currency
	Cost *Cost `json:"cost,omitempty"`

	// Date Order creation date
	Date *time.Time `json:"date,omitempty"`

	// Delivery Order delivery information
	Delivery *MessageOrderDelivery `json:"delivery,omitempty"`

	// Discount Represents a monetary value with its corresponding currency
	Discount *Cost `json:"discount,omitempty"`

	// ExternalID External identifier of an order
	ExternalID int64 `json:"external_id,omitempty"`

	// Items Array of order items
	Items []MessageOrderItem `json:"items,omitempty"`

	// Number Order number
	Number string `binding:"max=255" json:"number,omitempty"`

	// Payments Payments array
	Payments []MessageOrderPayment `json:"payments,omitempty"`

	// Status Order status
	Status *MessageOrderStatus `json:"status,omitempty"`

	// Url Order URL
	Url string `binding:"max=2048" json:"url,omitempty"`
}

// MessageOrderDelivery Order delivery information
type MessageOrderDelivery struct {
	// Address Delivery address
	Address string `json:"address,omitempty"`

	// Comment Delivery comment
	Comment string `json:"comment,omitempty"`

	// Name Delivery method name
	Name string `json:"name,omitempty"`

	// Price Represents a monetary value with its corresponding currency
	Price *Cost `json:"price,omitempty"`
}

// MessageOrderItem Order product
type MessageOrderItem struct {
	// ExternalID External identifier of a product
	ExternalID int64 `json:"external_id,omitempty"`

	// Img Product image
	Img string `binding:"max=2048" json:"img,omitempty"`

	// Name Product name
	Name string `binding:"max=255" json:"name,omitempty"`

	// Price Represents a monetary value with its corresponding currency
	Price    *Cost    `json:"price,omitempty"`
	Quantity Quantity `json:"quantity,omitempty"`

	// Url Product URL
	Url string `binding:"max=2048" json:"url,omitempty"`
}

// MessageOrderPayment Order payment information
type MessageOrderPayment struct {
	// Amount Represents a monetary value with its corresponding currency
	Amount *Cost `json:"amount,omitempty"`

	// Name Payment name
	Name string `json:"name,omitempty"`

	// Status Order payment status
	Status *MessageOrderPaymentStatus `json:"status,omitempty"`
}

// MessageOrderPaymentStatus Order payment status
type MessageOrderPaymentStatus struct {
	// Name Payment name
	Name string `json:"name,omitempty"`

	// Payed Payment execution indicator
	Payed *bool `json:"payed,omitempty"`
}

// MessageOrderStatus Order status
type MessageOrderStatus struct {
	Code MessageOrderStatusCode `binding:"enum-valid" json:"code,omitempty"`

	// Name Status name
	Name string `binding:"max=255" json:"name,omitempty"`
}

// MessageOrderStatusCode Status code
type MessageOrderStatusCode string

// MessageProduct Describes a product mentioned in a message
type MessageProduct struct {
	// Article Product description
	Article string `binding:"max=128" json:"article,omitempty"`

	// Cost Represents a monetary value with its corresponding currency
	Cost *Cost `json:"cost,omitempty"`

	// ID Product identifier
	ID uint64 `json:"id"`

	// Img Product image URL
	Img string `binding:"max=2048" json:"img,omitempty"`

	// Name Product name
	Name string `binding:"required,min=1,max=255" json:"name"`

	// Unit Units of measure of the product
	Unit string `binding:"max=16" json:"unit"`

	// Url Product URL
	Url string `binding:"max=2048" json:"url,omitempty"`
}

// MessageScope Message scope
type MessageScope string

// MessageStatus Message status
type MessageStatus string

// MessageTransportAttachments Transport attachments
type MessageTransportAttachments struct {
	// Suggestions Quick responses
	Suggestions []Suggestion `json:"suggestions,omitempty"`
}

// MessageType Message type
type MessageType string

// OrderMessageSetting Order messages support
type OrderMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// Originator Message sender type
type Originator string

// ProductMessageSetting Product messages support
type ProductMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// Quantity Quantity
type Quantity struct {
	// Unit Units of measure
	Unit string `binding:"max=16" json:"unit,omitempty"`

	// Value Quantitative value
	Value float64 `binding:"gte=0" json:"value,omitempty"`
}

// QuoteMessage Quoted message
type QuoteMessage struct {
	// Content Message text
	Content string `json:"content,omitempty"`

	// From Details about a user
	From *UserRef `json:"from,omitempty"`

	// ID Identifier of the quoted message
	ID int64 `json:"id,omitempty"`

	// Items Media attachments of the quoted message
	Items []MessageFile `json:"items,omitempty"`

	// Time Message sending time
	Time time.Time   `json:"time,omitempty"`
	Type MessageType `binding:"enum-valid" json:"type,omitempty"`
}

// Reactions Support for working with reactions for messages
type Reactions struct {
	// Dictionary Dictionary of available reactions
	Dictionary []string `json:"dictionary,omitempty"`

	// MaxCount Maximum number of reactions added from the system
	MaxCount int64 `json:"max_count,omitempty"`
}

// RejectReason Reason for template rejection (for `Rejected` status)
type RejectReason string

// SendMessageRequestCustomer Contains information about the customer sending a message
type SendMessageRequestCustomer struct {
	// Avatar Sender avatar URL
	Avatar *string `json:"avatar" mod:"trim,escape"`

	// Country Sender country code
	Country *string `json:"country" mod:"trim,escape"`

	// Email Sender email
	Email *string `json:"email" mod:"trim,escape"`

	// ExternalID External identifier of the sender
	ExternalID string `binding:"required,min=1,max=64" json:"external_id" mod:"trim,escape"`

	// FirstName Sender name
	FirstName *string `binding:"omitempty,max=255" json:"first_name" mod:"trim,escape"`

	// Language Sender language
	Language *string `json:"language" mod:"trim,escape"`

	// LastName Sender last name
	LastName *string `binding:"omitempty,max=255" json:"last_name,omitempty" mod:"trim,escape"`

	// Nickname Sender nickname
	Nickname string `binding:"required,min=1,max=255" json:"nickname" mod:"trim,escape"`

	// Phone Sender phone
	Phone *string `json:"phone" mod:"trim,escape"`

	// ProfileURL Sender profile URL
	ProfileURL *string `json:"profile_url" mod:"trim,escape"`

	// SecondaryExternalIDs Array of additional external customer identifiers
	SecondaryExternalIDs []string `binding:"omitempty,dive,min=0,max=64" json:"secondary_external_ids"`
	Utm                  *Utm     `json:"utm"`
}

// SendMessageRequestMessage Defines the message content in a sending request
type SendMessageRequestMessage struct {
	// CreatedAt Message creation date
	CreatedAt *time.Time `binding:"omitempty" json:"created_at"`

	// ExternalID External identifier of a message
	ExternalID *string `binding:"omitempty,min=0,max=255" json:"external_id"`

	// Items List of media objects in a message
	Items []SendMessageRequestMessageFileItem `binding:"omitempty,min=1,max=20,dive" json:"items"`

	// Note Message description (for messages with media data)
	Note  string        `binding:"omitempty,min=1,max=64000" json:"note" mod:"trim,escape"`
	Order *MessageOrder `binding:"required_if=Type order" json:"order,omitempty"`

	// PageLink Link to the page from which the message was sent
	PageLink *string         `binding:"omitempty,web_url_length,web_url" json:"page_link,omitempty"`
	Product  *MessageProduct `binding:"required_if=Type product" json:"product,omitempty"`

	// Text Message text
	Text string      `binding:"min=0,max=65535" json:"text"`
	Type MessageType `binding:"required,enum-valid" json:"type"`
}

// SendMessageRequestMessageFileItem Represents a file attachment in a message
type SendMessageRequestMessageFileItem struct {
	// Caption Description of the message media attachment
	Caption string `binding:"omitempty,max=1024" json:"caption,omitempty" mod:"trim,escape"`

	// ID UUID of the uploaded file
	ID openapi_types.UUID `binding:"required" json:"id"`
}

// SendingError Details about the error that occurred during the sending process
type SendingError struct {
	Code SendingErrorCode `binding:"enum-valid" json:"code"`

	// ExternalCode External error code
	ExternalCode *string `binding:"omitempty,max=100" json:"external_code,omitempty"`

	// Message Description of the error that occurred while sending
	Message string `json:"message" mod:"trim,escape"`
}

// SendingErrorCode Code representing possible sending error codes
type SendingErrorCode string

// SendingPolicy Message sending policy
type SendingPolicy struct {
	// AfterReplyTimeout Types of messages to send after response time expires
	AfterReplyTimeout SendingPolicyAfterReplyTimeout `json:"after_reply_timeout,omitempty"`

	// NewCustomer Types of messages to send to a new customer
	NewCustomer SendingPolicyNewCustomer `json:"new_customer,omitempty"`

	// Outgoing Outgoing message support
	Outgoing SendingPolicyOutgoing `json:"outgoing,omitempty"`
}

// SendingPolicyAfterReplyTimeout Types of messages to send after response time expires
type SendingPolicyAfterReplyTimeout string

// SendingPolicyNewCustomer Types of messages to send to a new customer
type SendingPolicyNewCustomer string

// SendingPolicyOutgoing Outgoing message support
type SendingPolicyOutgoing string

// StatusSetting Transmitting message status information
type StatusSetting struct {
	// Delivered Support for operation with messages of the given type
	Delivered ChannelFeature `json:"delivered,omitempty"`

	// Read Support for operation with messages of the given type
	Read ChannelFeature `json:"read,omitempty"`
}

// Suggestion Quick response suggestion
type Suggestion struct {
	// Payload Quick response payload
	Payload string `json:"payload,omitempty"`

	// Title Quick response name
	Title string         `json:"title,omitempty"`
	Type  SuggestionType `binding:"enum-valid" json:"type,omitempty"`
}

// SuggestionType Quick response type
type SuggestionType string

// Suggestions Support for quick response types
type Suggestions struct {
	// Email Support for operation with messages of the given type
	Email ChannelFeature `json:"email,omitempty"`

	// Phone Support for operation with messages of the given type
	Phone ChannelFeature `json:"phone,omitempty"`

	// Text Support for operation with messages of the given type
	Text ChannelFeature `json:"text,omitempty"`

	// Url Support for operation with messages of the given type
	Url ChannelFeature `json:"url,omitempty"`
}

// SystemAction System action of the message (for system type messages only)
type SystemAction string

// SystemMessage Represents system-generated events in messaging
type SystemMessage struct {
	// Action System action of the message (for system type messages only)
	Action SystemAction `json:"action"`

	// Responsible Details about a user
	Responsible *UserRef `json:"responsible,omitempty"`

	// User Details about a user
	User *UserRef `json:"user,omitempty"`
}

// Template defines model for Template.
type Template struct {
	// Body Template body
	Body string `json:"body" mod:"trim,escape"`

	// Buttons List of template buttons
	Buttons *TemplateButtons `json:"buttons,omitempty"`

	// Category Template category
	Category string `json:"category,omitempty"`

	// ChannelID Channel identifier
	ChannelID int64 `json:"channel_id"`

	// Code Template unique code
	Code *string `json:"code"`

	// Enabled Template activity indicator
	Enabled bool `json:"enabled"`

	// Example Template example
	Example *TemplateExample `json:"example,omitempty"`

	// Footer Template footer
	Footer string `json:"footer,omitempty"`

	// Header Header section of the template
	Header *TemplateHeader `json:"header,omitempty"`

	// ID Template identifier
	ID int64 `json:"id"`

	// Lang Template language
	Lang string `json:"lang,omitempty"`

	// Name Template name
	Name               string                     `binding:"required,min=1,max=512" json:"name" mod:"trim,escape"`
	Quality            *TemplateQuality           `binding:"omitempty,enum-valid" json:"quality,omitempty"`
	RejectionReason    RejectReason               `binding:"omitempty,enum-valid" json:"rejection_reason,omitempty"`
	Template           []TemplateItem             `json:"template"`
	Type               TemplateType               `json:"type,omitempty"`
	VerificationStatus TemplateVerificationStatus `binding:"omitempty,enum-valid" json:"verification_status,omitempty"`
}

// TemplateBase Template base
type TemplateBase struct {
	// Body Template body
	Body string `json:"body" mod:"trim,escape"`

	// Buttons List of template buttons
	Buttons *TemplateButtons `json:"buttons,omitempty"`

	// Category Template category
	Category *string `json:"category,omitempty" mod:"trim,escape"`

	// Footer Template footer
	Footer *string `json:"footer,omitempty" mod:"trim,escape"`

	// Header Header section of the template
	Header *TemplateHeader `json:"header,omitempty"`

	// Lang Template language
	Lang *string `json:"lang,omitempty" mod:"trim,escape"`

	// Name Template name
	Name               string                      `binding:"required,min=1,max=512" json:"name" mod:"trim,escape"`
	Quality            *TemplateQuality            `binding:"omitempty,enum-valid" json:"quality,omitempty"`
	RejectionReason    *RejectReason               `binding:"omitempty,enum-valid" json:"rejection_reason,omitempty" mod:"trim,escape"`
	Template           []TemplateItem              `json:"template"`
	VerificationStatus *TemplateVerificationStatus `binding:"omitempty,enum-valid" json:"verification_status,omitempty"`
}

// TemplateButton Template button
type TemplateButton struct {
	// Label Button name
	Label string `json:"label"`

	// Phone Phone number (for button type `phone`)
	Phone *string `json:"phone,omitempty"`

	// Type Button type
	Type TemplateButtonType `json:"type"`

	// Url URL address (for button type `url`)
	Url *string `json:"url,omitempty"`
}

// TemplateButtonType Button type
type TemplateButtonType string

// TemplateButtons List of template buttons
type TemplateButtons struct {
	Items []TemplateButton `json:"items,omitempty"`
}

// TemplateExample Template example
type TemplateExample struct {
	// Attachments Template attachments
	Attachments []TemplateExampleAttachment `json:"attachments,omitempty"`

	// Body Array of example template body values
	Body []string `json:"body,omitempty"`

	// Buttons Array of example template button values
	Buttons [][]string `json:"buttons,omitempty"`

	// Header Array of example values for the header section of the template
	Header []string `json:"header,omitempty"`
}

// TemplateExampleAttachment Example of a template attachment
type TemplateExampleAttachment struct {
	// Caption Original file name
	Caption string `json:"caption,omitempty"`

	// Id UID of the uploaded file
	Id openapi_types.UUID `json:"id"`
}

// TemplateHeader Header section of the template
type TemplateHeader struct {
	Content TemplateHeaderContent `json:"content,omitempty"`
}

// TemplateHeaderContent Template header content
type TemplateHeaderContent struct {
	// Body Text content of the header section (for content type `text`)
	Body string `json:"body,omitempty"`

	// Type Header section type
	Type TemplateHeaderContentType `json:"type"`
}

// TemplateHeaderContentType Header section type
type TemplateHeaderContentType string

// TemplateItem Template item
type TemplateItem struct {
	// Text Text of the template item (for type `text`)
	Text string           `json:"text,omitempty"`
	Type TemplateItemType `json:"-"`

	// VarType Template variable (for type `var`)
	VarType TemplateVarType `json:"var,omitempty"`
}

// TemplateItemType Template item type
type TemplateItemType uint8

// TemplateQuality Template quality
type TemplateQuality string

// TemplateSetting Support for message templates
type TemplateSetting struct {
	// Creation Support for creating templates in the system
	Creation bool `json:"creation,omitempty"`
}

// TemplateType Template type
type TemplateType string

// TemplateVarType Template variable type
type TemplateVarType uint8

// TemplateVerificationStatus Template verification status
type TemplateVerificationStatus string

// TextMessage Text message
type TextMessage struct {
	// Content Message text
	Content string `json:"content,omitempty"`

	// Quote Quoted message
	Quote *QuoteMessage `json:"quote,omitempty"`
}

// TextMessageSetting Text messages support
type TextMessageSetting struct {
	// Creating Support for operation with messages of the given type
	Creating ChannelFeature `json:"creating,omitempty"`

	// Deleting Support for operation with messages of the given type
	Deleting ChannelFeature `json:"deleting,omitempty"`

	// Editing Support for operation with messages of the given type
	Editing ChannelFeature `json:"editing,omitempty"`

	// MaxCharsCount Maximum number of characters in a text message
	MaxCharsCount *uint16 `json:"max_chars_count,omitempty"`

	// Quoting Support for operation with messages of the given type
	Quoting ChannelFeature `json:"quoting,omitempty"`

	// Reaction Support for operation with messages of the given type
	Reaction ChannelFeature `json:"reaction,omitempty"`
}

// UserRef Details about a user
type UserRef struct {
	// Available User status indicator (for user of the user type only)
	Available bool `json:"available,omitempty"`

	// Avatar User avatar
	Avatar string `json:"avatar,omitempty"`

	// Email User email (for customer type user only)
	Email string `json:"email,omitempty"`

	// ExternalID External identifier of a user
	ExternalID string `json:"external_id"`

	// FirstName User name (for customer and user types only)
	FirstName string `json:"first_name,omitempty"`

	// ID User identifier
	ID int64 `json:"id"`

	// IsBlocked User blocking indicator (for customer type user only)
	IsBlocked bool `json:"is_blocked,omitempty"`

	// IsSystem System user indicator (for bot type user only)
	IsSystem bool `json:"is_system,omitempty"`

	// IsTechnicalAccount Technical account indicator (for user of the user type only)
	IsTechnicalAccount bool `json:"is_technical_account,omitempty"`

	// LastName User last name (for customer and user types only)
	LastName string `json:"last_name,omitempty"`

	// Name User nickname
	Name string `json:"name"`

	// Phone User phone number
	Phone string `json:"phone,omitempty"`

	// Type User type
	Type UserType `json:"type"`

	// Username User name (for customer type user only)
	Username string `json:"username,omitempty"`
}

// UserType User type
type UserType string

// Utm UTM parameters for tracking marketing campaigns
type Utm struct {
	// Campaign Campaign
	Campaign *string `binding:"omitempty,min=1,max=255" json:"campaign,omitempty"`

	// Content Ad content
	Content *string `binding:"omitempty,min=1,max=255" json:"content,omitempty"`

	// Medium Medium
	Medium *string `binding:"omitempty,min=1,max=255" json:"medium,omitempty"`

	// Source Source
	Source *string `binding:"omitempty,min=1,max=255" json:"source,omitempty"`

	// Term Keyword
	Term *string `binding:"omitempty,min=1,max=255" json:"term,omitempty"`
}

// WAChannelProperties WhatsApp channel properties
type WAChannelProperties struct {
	ChannelQuality *WAChannelQuality `binding:"omitempty,enum-valid" json:"channel_quality,omitempty"`
	ChannelStatus  *WAChannelStatus  `binding:"omitempty,enum-valid" json:"channel_status,omitempty"`
	Tier           *int              `binding:"omitempty,min=0" json:"tier,omitempty"`
}

// WAChannelQuality WhatsApp channel quality
type WAChannelQuality string

// WAChannelStatus WhatsApp channel status
type WAChannelStatus string

// ChannelActiveQuery Boolean type
type ChannelActiveQuery = Boolean

// ChannelID defines model for ChannelIdPath.
type ChannelID = int64

// ChannelTypeQuery defines model for ChannelTypeQuery.
type ChannelTypeQuery = []ChannelType

// FileUUIDPath defines model for FileUUIDPath.
type FileUUIDPath = string

// ID defines model for IDQuery.
type ID = int

// LimitQuery defines model for LimitQuery.
type LimitQuery = int

// SinceQuery defines model for SinceQuery.
type SinceQuery = time.Time

// TemplateCodePath defines model for TemplateCodePath.
type TemplateCodePath = string

// UntilQuery defines model for UntilQuery.
type UntilQuery = time.Time

// ActivateChannelResponse defines model for ActivateChannelResponse.
type ActivateChannelResponse struct {
	// ActivatedAt Date and time of channel activation
	ActivatedAt time.Time `json:"activated_at" time_format:"2006-01-02T15:04:05Z07:00"`

	// ID Channel identifier
	ID int64 `json:"id"`
}

// ChannelsListResponse defines model for ChannelsListResponse.
type ChannelsListResponse = []Channel

// DeactivateChannelResponse defines model for DeactivateChannelResponse.
type DeactivateChannelResponse struct {
	// DeactivatedAt Date and time of channel deactivation
	DeactivatedAt time.Time `json:"deactivated_at" time_format:"2006-01-02T15:04:05Z07:00"`

	// ID Identifier of the deactivated channel
	ID int64 `json:"id"`
}

// EmptyResponse defines model for EmptyResponse.
type EmptyResponse = map[string]interface{}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Errors List of errors
	Errors *[]string `json:"errors,omitempty"`
}

// FileResponse File information
type FileResponse = File

// MarkMessagesReadUntilResponse defines model for MarkMessagesReadUntilResponse.
type MarkMessagesReadUntilResponse struct {
	// IDs Identifiers of messages marked as read
	IDs []int64 `json:"ids"`
}

// MessageResponse Contains details of a message
type MessageResponse = Message

// SendMessageResponse defines model for SendMessageResponse.
type SendMessageResponse struct {
	// MessageId Identifier of the created message
	MessageId int64 `json:"message_id"`

	// Time Message creation time
	Time time.Time `json:"time"`

	// Warnings Warnings that occurred while creating a message
	Warnings []string `json:"warnings,omitempty"`
}

// TemplateListResponse defines model for TemplateListResponse.
type TemplateListResponse = []Template

// UpdateChannelResponse defines model for UpdateChannelResponse.
type UpdateChannelResponse struct {
	// ID Channel identifier
	ID int64 `json:"id"`

	// UpdatedAt Date and time of last update
	UpdatedAt time.Time `json:"updated_at" time_format:"2006-01-02T15:04:05Z07:00"`
}

// UploadFileResponse Base file information
type UploadFileResponse = FileBase

// AckMessageRequest defines model for AckMessageRequest.
type AckMessageRequest struct {
	// Channel Sending channel identifier
	Channel int64 `binding:"required" json:"channel"`

	// CreatedAt Date and time of sending
	CreatedAt *time.Time    `json:"created_at"`
	Error     *SendingError `json:"error"`

	// ExternalMessageID External identifier of a message
	// Deprecated:
	ExternalMessageID *string `binding:"omitempty,max=255" json:"external_message_id,omitempty" mod:"trim,escape"`

	// Message Message identifier
	Message *MessageIdentifier `json:"message,omitempty"`

	// TransportMessageID Message identifier in transport
	TransportMessageID *string `binding:"omitempty,max=255" json:"transport_message_id" mod:"trim,escape"`
}

// ActivateChannelRequest defines model for ActivateChannelRequest.
type ActivateChannelRequest struct {
	// AvatarUrl Channel avatar URL
	AvatarUrl *string `binding:"omitempty,max=255" json:"avatar_url,omitempty" mod:"trim,escape"`

	// ExternalID External identifier of a channel
	ExternalID string `binding:"omitempty,max=64" json:"external_id" mod:"trim,escape"`

	// ID Channel identifier
	ID int64 `binding:"min=0" json:"id"`

	// Name Channel name
	Name *string `binding:"omitempty,max=100" json:"name,omitempty" mod:"trim,escape"`

	// Settings Channel settings
	Settings ChannelSettings `json:"settings,omitempty"`
	Type     ChannelType     `binding:"required,enum-valid" json:"type"`
}

// ActivateTemplateRequest defines model for ActivateTemplateRequest.
type ActivateTemplateRequest struct {
	// Body Template body
	Body string `json:"body" mod:"trim,escape"`

	// Buttons List of template buttons
	Buttons *TemplateButtons `json:"buttons,omitempty"`

	// Category Template category
	Category *string `json:"category,omitempty" mod:"trim,escape"`

	// Code Template unique code
	Code string `binding:"required,min=1,max=512" json:"code,omitempty" mod:"trim,escape"`

	// Footer Template footer
	Footer *string `json:"footer,omitempty" mod:"trim,escape"`

	// Header Header section of the template
	Header *TemplateHeader `json:"header,omitempty"`

	// Lang Template language
	Lang *string `json:"lang,omitempty" mod:"trim,escape"`

	// Name Template name
	Name               string                      `binding:"required,min=1,max=512" json:"name" mod:"trim,escape"`
	Quality            *TemplateQuality            `binding:"omitempty,enum-valid" json:"quality,omitempty"`
	RejectionReason    *RejectReason               `binding:"omitempty,enum-valid" json:"rejection_reason,omitempty" mod:"trim,escape"`
	Template           []TemplateItem              `json:"template"`
	Type               *TemplateType               `binding:"required" json:"type,omitempty"`
	VerificationStatus *TemplateVerificationStatus `binding:"omitempty,enum-valid" json:"verification_status,omitempty"`
}

// AddReactionRequest defines model for AddReactionRequest.
type AddReactionRequest struct {
	// Channel Sending channel identifier
	Channel int64             `binding:"required" json:"channel"`
	Message MessageIdentifier `binding:"required" json:"message"`

	// Reaction Removable reaction
	Reaction string `binding:"required" json:"reaction"`
}

// DeleteMessageRequest defines model for DeleteMessageRequest.
type DeleteMessageRequest struct {
	// Channel Channel identifier
	Channel int64             `binding:"required" json:"channel"`
	Message MessageIdentifier `binding:"required" json:"message"`
}

// DeleteReactionRequest defines model for DeleteReactionRequest.
type DeleteReactionRequest struct {
	// Channel Sending channel identifier
	Channel int64             `binding:"required" json:"channel"`
	Message MessageIdentifier `binding:"required" json:"message"`

	// Reaction Removable reaction
	Reaction *string `binding:"omitempty" json:"reaction"`
}

// EditMessageRequest defines model for EditMessageRequest.
type EditMessageRequest struct {
	// Channel Message channel
	Channel int64                     `binding:"required" json:"channel"`
	Message EditMessageRequestMessage `binding:"required" json:"message"`
}

// MarkMessageReadRequest defines model for MarkMessageReadRequest.
type MarkMessageReadRequest struct {
	// ChannelID Identifier of the sending channel
	ChannelID int64             `binding:"required" json:"channel_id"`
	Message   MessageIdentifier `binding:"required" json:"message"`
}

// MarkMessagesReadUntilRequest defines model for MarkMessagesReadUntilRequest.
type MarkMessagesReadUntilRequest struct {
	// ChannelID Channel identifier
	ChannelID int64 `binding:"required,min=1" json:"channel_id"`

	// CustomerExternalID Customer external identifier
	CustomerExternalID string `binding:"required" json:"customer_external_id" mod:"trim,escape"`

	// Until Read until date
	Until time.Time `binding:"required" json:"until"`
}

// RestoreMessageRequest defines model for RestoreMessageRequest.
type RestoreMessageRequest struct {
	// ChannelID Identifier of the sending channel
	ChannelID int64             `binding:"required" json:"channel_id"`
	Message   MessageIdentifier `binding:"required" json:"message"`
}

// SendHistoryMessageRequest defines model for SendHistoryMessageRequest.
type SendHistoryMessageRequest struct {
	// ChannelID Channel identifier
	ChannelID int64                       `binding:"required" json:"channel_id"`
	Customer  *SendMessageRequestCustomer `binding:"required" json:"customer"`

	// ExternalChatID External identifier
	ExternalChatID string                    `binding:"omitempty,min=0,max=64" json:"external_chat_id"`
	Message        SendMessageRequestMessage `binding:"required" json:"message"`
	Originator     Originator                `binding:"omitempty,enum-valid" json:"originator"`
	Quote          *MessageIdentifier        `binding:"omitempty" json:"quote"`

	// ReplyDeadline Deadline for response
	ReplyDeadline *time.Time `binding:"omitempty" json:"reply_deadline"`
}

// SendMessageRequest defines model for SendMessageRequest.
type SendMessageRequest struct {
	// Channel Channel identifier
	Channel  int64                       `binding:"required" json:"channel"`
	Customer *SendMessageRequestCustomer `binding:"omitempty" json:"customer"`

	// ExternalChatID External identifier
	ExternalChatID string                    `binding:"min=0,max=64" json:"external_chat_id"`
	Message        SendMessageRequestMessage `binding:"required" json:"message"`
	Originator     Originator                `binding:"enum-valid" json:"originator"`
	Quote          *MessageIdentifier        `json:"quote"`

	// ReplyDeadline Deadline for response
	ReplyDeadline *time.Time `binding:"omitempty" json:"reply_deadline"`

	// SecondaryExternalChatIDs Array of additional external chat identifiers
	SecondaryExternalChatIDs []string `binding:"omitempty,dive,min=0,max=64" json:"secondary_external_chat_ids"`
	// Deprecated:
	User *SendMessageRequestCustomer `binding:"omitempty" json:"user"`
}

// UpdateChannelRequest defines model for UpdateChannelRequest.
type UpdateChannelRequest struct {
	// AvatarUrl Channel avatar URL
	AvatarUrl *string `binding:"omitempty,max=255" json:"avatar_url,omitempty" mod:"trim,escape"`

	// ExternalID External identifier
	ExternalID *string `binding:"omitempty,max=64" json:"external_id,omitempty" mod:"trim,escape"`

	// Name Channel name
	Name *string `binding:"omitempty,max=100" json:"name,omitempty" mod:"trim,escape"`

	// Settings Channel settings
	Settings ChannelSettings `json:"settings,omitempty"`
	Type     *ChannelType    `binding:"omitempty,enum-valid" json:"type,omitempty"`
}

// UpdateTemplateRequest defines model for UpdateTemplateRequest.
type UpdateTemplateRequest struct {
	// Body Template body
	Body string `json:"body" mod:"trim,escape"`

	// Buttons List of template buttons
	Buttons *TemplateButtons `json:"buttons,omitempty"`

	// Category Template category
	Category *string `json:"category,omitempty" mod:"trim,escape"`

	// Footer Template footer
	Footer *string `json:"footer,omitempty" mod:"trim,escape"`

	// Header Header section of the template
	Header *TemplateHeader `json:"header,omitempty"`

	// Lang Template language
	Lang *string `json:"lang,omitempty" mod:"trim,escape"`

	// Name Template name
	Name               string                     `binding:"required,min=1,max=512" json:"name" mod:"trim,escape"`
	Quality            *TemplateQuality           `binding:"omitempty,enum-valid" json:"quality,omitempty"`
	RejectionReason    *RejectReason              `binding:"omitempty,enum-valid" json:"rejection_reason,omitempty" mod:"trim,escape"`
	Template           []TemplateItem             `json:"template"`
	VerificationStatus TemplateVerificationStatus `binding:"omitempty,enum-valid" json:"verification_status,omitempty"`
}

// UploadFileByUrlRequest defines model for UploadFileByUrlRequest.
type UploadFileByUrlRequest struct {
	// Url Upload source URL
	Url string `binding:"web_url" json:"url" mod:"trim,escape"`
}

// ListChannelsParams defines parameters for ListChannels.
type ListChannelsParams struct {
	// ID Identifier of the requested object
	ID ID `binding:"omitempty,min=1" form:"id,omitempty" json:"id,omitempty"`

	// Active Channel activity flag
	Active *ChannelActiveQuery `binding:"omitempty,enum-valid" form:"active,omitempty" json:"active,omitempty"`

	// Types Channel types
	Types ChannelTypeQuery `binding:"omitempty,enum-valid" form:"types,omitempty" json:"types,omitempty"`

	// Since Lower limit of the date of the last object update
	Since SinceQuery `form:"since,omitempty" json:"since,omitempty" time_format:"2006-01-02T15:04:05.999999Z07:00" time_utc:"1"`

	// Until Upper limit of the date of the last object update
	Until UntilQuery `form:"until,omitempty" json:"until,omitempty" time_format:"2006-01-02T15:04:05.999999Z07:00" time_utc:"1"`

	// Limit The number of elements in the response. Default value is 100
	Limit LimitQuery `binding:"omitempty,min=1,max=1000" form:"limit,omitempty" json:"limit,omitempty"`
}

// ActivateChannelJSONBody defines parameters for ActivateChannel.
type ActivateChannelJSONBody struct {
	// AvatarUrl Channel avatar URL
	AvatarUrl *string `binding:"omitempty,max=255" json:"avatar_url,omitempty" mod:"trim,escape"`

	// ExternalID External identifier of a channel
	ExternalID string `binding:"omitempty,max=64" json:"external_id" mod:"trim,escape"`

	// ID Channel identifier
	ID int64 `binding:"min=0" json:"id"`

	// Name Channel name
	Name *string `binding:"omitempty,max=100" json:"name,omitempty" mod:"trim,escape"`

	// Settings Channel settings
	Settings ChannelSettings `json:"settings,omitempty"`
	Type     ChannelType     `binding:"required,enum-valid" json:"type"`
}

// UpdateChannelJSONBody defines parameters for UpdateChannel.
type UpdateChannelJSONBody struct {
	// AvatarUrl Channel avatar URL
	AvatarUrl *string `binding:"omitempty,max=255" json:"avatar_url,omitempty" mod:"trim,escape"`

	// ExternalID External identifier
	ExternalID *string `binding:"omitempty,max=64" json:"external_id,omitempty" mod:"trim,escape"`

	// Name Channel name
	Name *string `binding:"omitempty,max=100" json:"name,omitempty" mod:"trim,escape"`

	// Settings Channel settings
	Settings ChannelSettings `json:"settings,omitempty"`
	Type     *ChannelType    `binding:"omitempty,enum-valid" json:"type,omitempty"`
}

// ActivateTemplateJSONBody defines parameters for ActivateTemplate.
type ActivateTemplateJSONBody struct {
	// Body Template body
	Body string `json:"body" mod:"trim,escape"`

	// Buttons List of template buttons
	Buttons *TemplateButtons `json:"buttons,omitempty"`

	// Category Template category
	Category *string `json:"category,omitempty" mod:"trim,escape"`

	// Code Template unique code
	Code string `binding:"required,min=1,max=512" json:"code,omitempty" mod:"trim,escape"`

	// Footer Template footer
	Footer *string `json:"footer,omitempty" mod:"trim,escape"`

	// Header Header section of the template
	Header *TemplateHeader `json:"header,omitempty"`

	// Lang Template language
	Lang *string `json:"lang,omitempty" mod:"trim,escape"`

	// Name Template name
	Name               string                      `binding:"required,min=1,max=512" json:"name" mod:"trim,escape"`
	Quality            *TemplateQuality            `binding:"omitempty,enum-valid" json:"quality,omitempty"`
	RejectionReason    *RejectReason               `binding:"omitempty,enum-valid" json:"rejection_reason,omitempty" mod:"trim,escape"`
	Template           []TemplateItem              `json:"template"`
	Type               *TemplateType               `binding:"required" json:"type,omitempty"`
	VerificationStatus *TemplateVerificationStatus `binding:"omitempty,enum-valid" json:"verification_status,omitempty"`
}

// UpdateTemplateJSONBody defines parameters for UpdateTemplate.
type UpdateTemplateJSONBody struct {
	// Body Template body
	Body string `json:"body" mod:"trim,escape"`

	// Buttons List of template buttons
	Buttons *TemplateButtons `json:"buttons,omitempty"`

	// Category Template category
	Category *string `json:"category,omitempty" mod:"trim,escape"`

	// Footer Template footer
	Footer *string `json:"footer,omitempty" mod:"trim,escape"`

	// Header Header section of the template
	Header *TemplateHeader `json:"header,omitempty"`

	// Lang Template language
	Lang *string `json:"lang,omitempty" mod:"trim,escape"`

	// Name Template name
	Name               string                     `binding:"required,min=1,max=512" json:"name" mod:"trim,escape"`
	Quality            *TemplateQuality           `binding:"omitempty,enum-valid" json:"quality,omitempty"`
	RejectionReason    *RejectReason              `binding:"omitempty,enum-valid" json:"rejection_reason,omitempty" mod:"trim,escape"`
	Template           []TemplateItem             `json:"template"`
	VerificationStatus TemplateVerificationStatus `binding:"omitempty,enum-valid" json:"verification_status,omitempty"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody = openapi_types.File

// UploadFileByUrlJSONBody defines parameters for UploadFileByUrl.
type UploadFileByUrlJSONBody struct {
	// Url Upload source URL
	Url string `binding:"web_url" json:"url" mod:"trim,escape"`
}

// DeleteMessageJSONBody defines parameters for DeleteMessage.
type DeleteMessageJSONBody struct {
	// Channel Channel identifier
	Channel int64             `binding:"required" json:"channel"`
	Message MessageIdentifier `binding:"required" json:"message"`
}

// SendMessageJSONBody defines parameters for SendMessage.
type SendMessageJSONBody struct {
	// Channel Channel identifier
	Channel  int64                       `binding:"required" json:"channel"`
	Customer *SendMessageRequestCustomer `binding:"omitempty" json:"customer"`

	// ExternalChatID External identifier
	ExternalChatID string                    `binding:"min=0,max=64" json:"external_chat_id"`
	Message        SendMessageRequestMessage `binding:"required" json:"message"`
	Originator     Originator                `binding:"enum-valid" json:"originator"`
	Quote          *MessageIdentifier        `json:"quote"`

	// ReplyDeadline Deadline for response
	ReplyDeadline *time.Time `binding:"omitempty" json:"reply_deadline"`

	// SecondaryExternalChatIDs Array of additional external chat identifiers
	SecondaryExternalChatIDs []string `binding:"omitempty,dive,min=0,max=64" json:"secondary_external_chat_ids"`
	// Deprecated:
	User *SendMessageRequestCustomer `binding:"omitempty" json:"user"`
}

// EditMessageJSONBody defines parameters for EditMessage.
type EditMessageJSONBody struct {
	// Channel Message channel
	Channel int64                     `binding:"required" json:"channel"`
	Message EditMessageRequestMessage `binding:"required" json:"message"`
}

// AckMessageJSONBody defines parameters for AckMessage.
type AckMessageJSONBody struct {
	// Channel Sending channel identifier
	Channel int64 `binding:"required" json:"channel"`

	// CreatedAt Date and time of sending
	CreatedAt *time.Time    `json:"created_at"`
	Error     *SendingError `json:"error"`

	// ExternalMessageID External identifier of a message
	// Deprecated:
	ExternalMessageID *string `binding:"omitempty,max=255" json:"external_message_id,omitempty" mod:"trim,escape"`

	// Message Message identifier
	Message *MessageIdentifier `json:"message,omitempty"`

	// TransportMessageID Message identifier in transport
	TransportMessageID *string `binding:"omitempty,max=255" json:"transport_message_id" mod:"trim,escape"`
}

// SendHistoryMessageJSONBody defines parameters for SendHistoryMessage.
type SendHistoryMessageJSONBody struct {
	// ChannelID Channel identifier
	ChannelID int64                       `binding:"required" json:"channel_id"`
	Customer  *SendMessageRequestCustomer `binding:"required" json:"customer"`

	// ExternalChatID External identifier
	ExternalChatID string                    `binding:"omitempty,min=0,max=64" json:"external_chat_id"`
	Message        SendMessageRequestMessage `binding:"required" json:"message"`
	Originator     Originator                `binding:"omitempty,enum-valid" json:"originator"`
	Quote          *MessageIdentifier        `binding:"omitempty" json:"quote"`

	// ReplyDeadline Deadline for response
	ReplyDeadline *time.Time `binding:"omitempty" json:"reply_deadline"`
}

// DeleteMessageReactionJSONBody defines parameters for DeleteMessageReaction.
type DeleteMessageReactionJSONBody struct {
	// Channel Sending channel identifier
	Channel int64             `binding:"required" json:"channel"`
	Message MessageIdentifier `binding:"required" json:"message"`

	// Reaction Removable reaction
	Reaction *string `binding:"omitempty" json:"reaction"`
}

// AddMessageReactionJSONBody defines parameters for AddMessageReaction.
type AddMessageReactionJSONBody struct {
	// Channel Sending channel identifier
	Channel int64             `binding:"required" json:"channel"`
	Message MessageIdentifier `binding:"required" json:"message"`

	// Reaction Removable reaction
	Reaction string `binding:"required" json:"reaction"`
}

// MarkMessageReadJSONBody defines parameters for MarkMessageRead.
type MarkMessageReadJSONBody struct {
	// ChannelID Identifier of the sending channel
	ChannelID int64             `binding:"required" json:"channel_id"`
	Message   MessageIdentifier `binding:"required" json:"message"`
}

// MarkMessagesReadUntilJSONBody defines parameters for MarkMessagesReadUntil.
type MarkMessagesReadUntilJSONBody struct {
	// ChannelID Channel identifier
	ChannelID int64 `binding:"required,min=1" json:"channel_id"`

	// CustomerExternalID Customer external identifier
	CustomerExternalID string `binding:"required" json:"customer_external_id" mod:"trim,escape"`

	// Until Read until date
	Until time.Time `binding:"required" json:"until"`
}

// RestoreMessageJSONBody defines parameters for RestoreMessage.
type RestoreMessageJSONBody struct {
	// ChannelID Identifier of the sending channel
	ChannelID int64             `binding:"required" json:"channel_id"`
	Message   MessageIdentifier `binding:"required" json:"message"`
}

// ActivateChannelJSONRequestBody defines body for ActivateChannel for application/json ContentType.
type ActivateChannelJSONRequestBody ActivateChannelJSONBody

// UpdateChannelJSONRequestBody defines body for UpdateChannel for application/json ContentType.
type UpdateChannelJSONRequestBody UpdateChannelJSONBody

// ActivateTemplateJSONRequestBody defines body for ActivateTemplate for application/json ContentType.
type ActivateTemplateJSONRequestBody ActivateTemplateJSONBody

// UpdateTemplateJSONRequestBody defines body for UpdateTemplate for application/json ContentType.
type UpdateTemplateJSONRequestBody UpdateTemplateJSONBody

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody = UploadFileMultipartBody

// UploadFileByUrlJSONRequestBody defines body for UploadFileByUrl for application/json ContentType.
type UploadFileByUrlJSONRequestBody UploadFileByUrlJSONBody

// DeleteMessageJSONRequestBody defines body for DeleteMessage for application/json ContentType.
type DeleteMessageJSONRequestBody DeleteMessageJSONBody

// SendMessageJSONRequestBody defines body for SendMessage for application/json ContentType.
type SendMessageJSONRequestBody SendMessageJSONBody

// EditMessageJSONRequestBody defines body for EditMessage for application/json ContentType.
type EditMessageJSONRequestBody EditMessageJSONBody

// AckMessageJSONRequestBody defines body for AckMessage for application/json ContentType.
type AckMessageJSONRequestBody AckMessageJSONBody

// SendHistoryMessageJSONRequestBody defines body for SendHistoryMessage for application/json ContentType.
type SendHistoryMessageJSONRequestBody SendHistoryMessageJSONBody

// DeleteMessageReactionJSONRequestBody defines body for DeleteMessageReaction for application/json ContentType.
type DeleteMessageReactionJSONRequestBody DeleteMessageReactionJSONBody

// AddMessageReactionJSONRequestBody defines body for AddMessageReaction for application/json ContentType.
type AddMessageReactionJSONRequestBody AddMessageReactionJSONBody

// MarkMessageReadJSONRequestBody defines body for MarkMessageRead for application/json ContentType.
type MarkMessageReadJSONRequestBody MarkMessageReadJSONBody

// MarkMessagesReadUntilJSONRequestBody defines body for MarkMessagesReadUntil for application/json ContentType.
type MarkMessagesReadUntilJSONRequestBody MarkMessagesReadUntilJSONBody

// RestoreMessageJSONRequestBody defines body for RestoreMessage for application/json ContentType.
type RestoreMessageJSONRequestBody RestoreMessageJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListChannels request
	ListChannels(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateChannelWithBody request with any body
	ActivateChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateChannel(ctx context.Context, body ActivateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateChannel request
	DeactivateChannel(ctx context.Context, channelID ChannelID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelWithBody request with any body
	UpdateChannelWithBody(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannel(ctx context.Context, channelID ChannelID, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateTemplateWithBody request with any body
	ActivateTemplateWithBody(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateTemplate(ctx context.Context, channelID ChannelID, body ActivateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateTemplate request
	DeactivateTemplate(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTemplateWithBody request with any body
	UpdateTemplateWithBody(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTemplate(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileWithBody request with any body
	UploadFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileByUrlWithBody request with any body
	UploadFileByUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadFileByUrl(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFileUrl request
	GetFileUrl(ctx context.Context, id FileUUIDPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMessageWithBody request with any body
	DeleteMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteMessage(ctx context.Context, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendMessageWithBody request with any body
	SendMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMessage(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditMessageWithBody request with any body
	EditMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditMessage(ctx context.Context, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AckMessageWithBody request with any body
	AckMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AckMessage(ctx context.Context, body AckMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendHistoryMessageWithBody request with any body
	SendHistoryMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendHistoryMessage(ctx context.Context, body SendHistoryMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMessageReactionWithBody request with any body
	DeleteMessageReactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteMessageReaction(ctx context.Context, body DeleteMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMessageReactionWithBody request with any body
	AddMessageReactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMessageReaction(ctx context.Context, body AddMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkMessageReadWithBody request with any body
	MarkMessageReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkMessageRead(ctx context.Context, body MarkMessageReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkMessagesReadUntilWithBody request with any body
	MarkMessagesReadUntilWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkMessagesReadUntil(ctx context.Context, body MarkMessagesReadUntilJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreMessageWithBody request with any body
	RestoreMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreMessage(ctx context.Context, body RestoreMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplates request
	GetTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListChannels(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateChannel(ctx context.Context, body ActivateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateChannel(ctx context.Context, channelID ChannelID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateChannelRequest(c.Server, channelID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelWithBody(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelRequestWithBody(c.Server, channelID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannel(ctx context.Context, channelID ChannelID, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelRequest(c.Server, channelID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateTemplateWithBody(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateTemplateRequestWithBody(c.Server, channelID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateTemplate(ctx context.Context, channelID ChannelID, body ActivateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateTemplateRequest(c.Server, channelID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateTemplate(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateTemplateRequest(c.Server, channelID, templateCode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplateWithBody(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequestWithBody(c.Server, channelID, templateCode, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTemplate(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTemplateRequest(c.Server, channelID, templateCode, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileByUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileByUrlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileByUrl(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileByUrlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFileUrl(ctx context.Context, id FileUUIDPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileUrlRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessage(ctx context.Context, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessage(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMessage(ctx context.Context, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AckMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAckMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AckMessage(ctx context.Context, body AckMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAckMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendHistoryMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendHistoryMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendHistoryMessage(ctx context.Context, body SendHistoryMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendHistoryMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessageReactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageReactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessageReaction(ctx context.Context, body DeleteMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageReactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMessageReactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMessageReactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMessageReaction(ctx context.Context, body AddMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMessageReactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkMessageReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkMessageReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkMessageRead(ctx context.Context, body MarkMessageReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkMessageReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkMessagesReadUntilWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkMessagesReadUntilRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkMessagesReadUntil(ctx context.Context, body MarkMessagesReadUntilJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkMessagesReadUntilRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreMessage(ctx context.Context, body RestoreMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListChannelsRequest generates requests for ListChannels
func NewListChannelsRequest(server string, params *ListChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.ID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, params.Types); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateChannelRequest calls the generic ActivateChannel builder with application/json body
func NewActivateChannelRequest(server string, body ActivateChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewActivateChannelRequestWithBody generates requests for ActivateChannel with any type of body
func NewActivateChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeactivateChannelRequest generates requests for DeactivateChannel
func NewDeactivateChannelRequest(server string, channelID ChannelID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelRequest calls the generic UpdateChannel builder with application/json body
func NewUpdateChannelRequest(server string, channelID ChannelID, body UpdateChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelRequestWithBody(server, channelID, "application/json", bodyReader)
}

// NewUpdateChannelRequestWithBody generates requests for UpdateChannel with any type of body
func NewUpdateChannelRequestWithBody(server string, channelID ChannelID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivateTemplateRequest calls the generic ActivateTemplate builder with application/json body
func NewActivateTemplateRequest(server string, channelID ChannelID, body ActivateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateTemplateRequestWithBody(server, channelID, "application/json", bodyReader)
}

// NewActivateTemplateRequestWithBody generates requests for ActivateTemplate with any type of body
func NewActivateTemplateRequestWithBody(server string, channelID ChannelID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s/templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeactivateTemplateRequest generates requests for DeactivateTemplate
func NewDeactivateTemplateRequest(server string, channelID ChannelID, templateCode TemplateCodePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_code", runtime.ParamLocationPath, templateCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTemplateRequest calls the generic UpdateTemplate builder with application/json body
func NewUpdateTemplateRequest(server string, channelID ChannelID, templateCode TemplateCodePath, body UpdateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTemplateRequestWithBody(server, channelID, templateCode, "application/json", bodyReader)
}

// NewUpdateTemplateRequestWithBody generates requests for UpdateTemplate with any type of body
func NewUpdateTemplateRequestWithBody(server string, channelID ChannelID, templateCode TemplateCodePath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channel_id", runtime.ParamLocationPath, channelID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_code", runtime.ParamLocationPath, templateCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadFileRequestWithBody generates requests for UploadFile with any type of body
func NewUploadFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadFileByUrlRequest calls the generic UploadFileByUrl builder with application/json body
func NewUploadFileByUrlRequest(server string, body UploadFileByUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadFileByUrlRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadFileByUrlRequestWithBody generates requests for UploadFileByUrl with any type of body
func NewUploadFileByUrlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/upload_by_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFileUrlRequest generates requests for GetFileUrl
func NewGetFileUrlRequest(server string, id FileUUIDPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMessageRequest calls the generic DeleteMessage builder with application/json body
func NewDeleteMessageRequest(server string, body DeleteMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteMessageRequestWithBody generates requests for DeleteMessage with any type of body
func NewDeleteMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendMessageRequest calls the generic SendMessage builder with application/json body
func NewSendMessageRequest(server string, body SendMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewSendMessageRequestWithBody generates requests for SendMessage with any type of body
func NewSendMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditMessageRequest calls the generic EditMessage builder with application/json body
func NewEditMessageRequest(server string, body EditMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewEditMessageRequestWithBody generates requests for EditMessage with any type of body
func NewEditMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAckMessageRequest calls the generic AckMessage builder with application/json body
func NewAckMessageRequest(server string, body AckMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAckMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewAckMessageRequestWithBody generates requests for AckMessage with any type of body
func NewAckMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/ack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendHistoryMessageRequest calls the generic SendHistoryMessage builder with application/json body
func NewSendHistoryMessageRequest(server string, body SendHistoryMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendHistoryMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewSendHistoryMessageRequestWithBody generates requests for SendHistoryMessage with any type of body
func NewSendHistoryMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMessageReactionRequest calls the generic DeleteMessageReaction builder with application/json body
func NewDeleteMessageReactionRequest(server string, body DeleteMessageReactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteMessageReactionRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteMessageReactionRequestWithBody generates requests for DeleteMessageReaction with any type of body
func NewDeleteMessageReactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/reaction")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddMessageReactionRequest calls the generic AddMessageReaction builder with application/json body
func NewAddMessageReactionRequest(server string, body AddMessageReactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMessageReactionRequestWithBody(server, "application/json", bodyReader)
}

// NewAddMessageReactionRequestWithBody generates requests for AddMessageReaction with any type of body
func NewAddMessageReactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/reaction")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkMessageReadRequest calls the generic MarkMessageRead builder with application/json body
func NewMarkMessageReadRequest(server string, body MarkMessageReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkMessageReadRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkMessageReadRequestWithBody generates requests for MarkMessageRead with any type of body
func NewMarkMessageReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/read")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkMessagesReadUntilRequest calls the generic MarkMessagesReadUntil builder with application/json body
func NewMarkMessagesReadUntilRequest(server string, body MarkMessagesReadUntilJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkMessagesReadUntilRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkMessagesReadUntilRequestWithBody generates requests for MarkMessagesReadUntil with any type of body
func NewMarkMessagesReadUntilRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/read_until")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreMessageRequest calls the generic RestoreMessage builder with application/json body
func NewRestoreMessageRequest(server string, body RestoreMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewRestoreMessageRequestWithBody generates requests for RestoreMessage with any type of body
func NewRestoreMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/restore")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTemplatesRequest generates requests for GetTemplates
func NewGetTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListChannelsWithResponse request
	ListChannelsWithResponse(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*ListChannelsResp, error)

	// ActivateChannelWithBodyWithResponse request with any body
	ActivateChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateChannelResp, error)

	ActivateChannelWithResponse(ctx context.Context, body ActivateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateChannelResp, error)

	// DeactivateChannelWithResponse request
	DeactivateChannelWithResponse(ctx context.Context, channelID ChannelID, reqEditors ...RequestEditorFn) (*DeactivateChannelResp, error)

	// UpdateChannelWithBodyWithResponse request with any body
	UpdateChannelWithBodyWithResponse(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelResp, error)

	UpdateChannelWithResponse(ctx context.Context, channelID ChannelID, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelResp, error)

	// ActivateTemplateWithBodyWithResponse request with any body
	ActivateTemplateWithBodyWithResponse(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateTemplateResp, error)

	ActivateTemplateWithResponse(ctx context.Context, channelID ChannelID, body ActivateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateTemplateResp, error)

	// DeactivateTemplateWithResponse request
	DeactivateTemplateWithResponse(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, reqEditors ...RequestEditorFn) (*DeactivateTemplateResp, error)

	// UpdateTemplateWithBodyWithResponse request with any body
	UpdateTemplateWithBodyWithResponse(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error)

	UpdateTemplateWithResponse(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error)

	// UploadFileWithBodyWithResponse request with any body
	UploadFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileResp, error)

	// UploadFileByUrlWithBodyWithResponse request with any body
	UploadFileByUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error)

	UploadFileByUrlWithResponse(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error)

	// GetFileUrlWithResponse request
	GetFileUrlWithResponse(ctx context.Context, id FileUUIDPath, reqEditors ...RequestEditorFn) (*GetFileUrlResp, error)

	// DeleteMessageWithBodyWithResponse request with any body
	DeleteMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error)

	DeleteMessageWithResponse(ctx context.Context, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error)

	// SendMessageWithBodyWithResponse request with any body
	SendMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageResp, error)

	SendMessageWithResponse(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageResp, error)

	// EditMessageWithBodyWithResponse request with any body
	EditMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMessageResp, error)

	EditMessageWithResponse(ctx context.Context, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMessageResp, error)

	// AckMessageWithBodyWithResponse request with any body
	AckMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AckMessageResp, error)

	AckMessageWithResponse(ctx context.Context, body AckMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*AckMessageResp, error)

	// SendHistoryMessageWithBodyWithResponse request with any body
	SendHistoryMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendHistoryMessageResp, error)

	SendHistoryMessageWithResponse(ctx context.Context, body SendHistoryMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendHistoryMessageResp, error)

	// DeleteMessageReactionWithBodyWithResponse request with any body
	DeleteMessageReactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMessageReactionResp, error)

	DeleteMessageReactionWithResponse(ctx context.Context, body DeleteMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMessageReactionResp, error)

	// AddMessageReactionWithBodyWithResponse request with any body
	AddMessageReactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMessageReactionResp, error)

	AddMessageReactionWithResponse(ctx context.Context, body AddMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMessageReactionResp, error)

	// MarkMessageReadWithBodyWithResponse request with any body
	MarkMessageReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkMessageReadResp, error)

	MarkMessageReadWithResponse(ctx context.Context, body MarkMessageReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkMessageReadResp, error)

	// MarkMessagesReadUntilWithBodyWithResponse request with any body
	MarkMessagesReadUntilWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkMessagesReadUntilResp, error)

	MarkMessagesReadUntilWithResponse(ctx context.Context, body MarkMessagesReadUntilJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkMessagesReadUntilResp, error)

	// RestoreMessageWithBodyWithResponse request with any body
	RestoreMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreMessageResp, error)

	RestoreMessageWithResponse(ctx context.Context, body RestoreMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreMessageResp, error)

	// GetTemplatesWithResponse request
	GetTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTemplatesResp, error)
}

type ListChannelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelsListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListChannelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChannelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateChannelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivateChannelResponse
	JSON201      *ActivateChannelResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActivateChannelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateChannelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateChannelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeactivateChannelResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeactivateChannelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateChannelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateChannelResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateChannelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActivateTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeactivateTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTemplateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTemplateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTemplateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadFileResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileByUrlResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadFileResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadFileByUrlResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileByUrlResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileUrlResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetFileUrlResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileUrlResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendMessageResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EditMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AckMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AckMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AckMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendHistoryMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendMessageResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendHistoryMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendHistoryMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMessageReactionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMessageReactionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessageReactionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMessageReactionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddMessageReactionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMessageReactionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkMessageReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MarkMessageReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkMessageReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkMessagesReadUntilResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarkMessagesReadUntilResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MarkMessagesReadUntilResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkMessagesReadUntilResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RestoreMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemplateListResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTemplatesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListChannelsWithResponse request returning *ListChannelsResp
func (c *ClientWithResponses) ListChannelsWithResponse(ctx context.Context, params *ListChannelsParams, reqEditors ...RequestEditorFn) (*ListChannelsResp, error) {
	rsp, err := c.ListChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListChannelsResp(rsp)
}

// ActivateChannelWithBodyWithResponse request with arbitrary body returning *ActivateChannelResp
func (c *ClientWithResponses) ActivateChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateChannelResp, error) {
	rsp, err := c.ActivateChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateChannelResp(rsp)
}

func (c *ClientWithResponses) ActivateChannelWithResponse(ctx context.Context, body ActivateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateChannelResp, error) {
	rsp, err := c.ActivateChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateChannelResp(rsp)
}

// DeactivateChannelWithResponse request returning *DeactivateChannelResp
func (c *ClientWithResponses) DeactivateChannelWithResponse(ctx context.Context, channelID ChannelID, reqEditors ...RequestEditorFn) (*DeactivateChannelResp, error) {
	rsp, err := c.DeactivateChannel(ctx, channelID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateChannelResp(rsp)
}

// UpdateChannelWithBodyWithResponse request with arbitrary body returning *UpdateChannelResp
func (c *ClientWithResponses) UpdateChannelWithBodyWithResponse(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelResp, error) {
	rsp, err := c.UpdateChannelWithBody(ctx, channelID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelResp(rsp)
}

func (c *ClientWithResponses) UpdateChannelWithResponse(ctx context.Context, channelID ChannelID, body UpdateChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelResp, error) {
	rsp, err := c.UpdateChannel(ctx, channelID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChannelResp(rsp)
}

// ActivateTemplateWithBodyWithResponse request with arbitrary body returning *ActivateTemplateResp
func (c *ClientWithResponses) ActivateTemplateWithBodyWithResponse(ctx context.Context, channelID ChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateTemplateResp, error) {
	rsp, err := c.ActivateTemplateWithBody(ctx, channelID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateTemplateResp(rsp)
}

func (c *ClientWithResponses) ActivateTemplateWithResponse(ctx context.Context, channelID ChannelID, body ActivateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateTemplateResp, error) {
	rsp, err := c.ActivateTemplate(ctx, channelID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateTemplateResp(rsp)
}

// DeactivateTemplateWithResponse request returning *DeactivateTemplateResp
func (c *ClientWithResponses) DeactivateTemplateWithResponse(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, reqEditors ...RequestEditorFn) (*DeactivateTemplateResp, error) {
	rsp, err := c.DeactivateTemplate(ctx, channelID, templateCode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateTemplateResp(rsp)
}

// UpdateTemplateWithBodyWithResponse request with arbitrary body returning *UpdateTemplateResp
func (c *ClientWithResponses) UpdateTemplateWithBodyWithResponse(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error) {
	rsp, err := c.UpdateTemplateWithBody(ctx, channelID, templateCode, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResp(rsp)
}

func (c *ClientWithResponses) UpdateTemplateWithResponse(ctx context.Context, channelID ChannelID, templateCode TemplateCodePath, body UpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTemplateResp, error) {
	rsp, err := c.UpdateTemplate(ctx, channelID, templateCode, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTemplateResp(rsp)
}

// UploadFileWithBodyWithResponse request with arbitrary body returning *UploadFileResp
func (c *ClientWithResponses) UploadFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileResp, error) {
	rsp, err := c.UploadFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileResp(rsp)
}

// UploadFileByUrlWithBodyWithResponse request with arbitrary body returning *UploadFileByUrlResp
func (c *ClientWithResponses) UploadFileByUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error) {
	rsp, err := c.UploadFileByUrlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileByUrlResp(rsp)
}

func (c *ClientWithResponses) UploadFileByUrlWithResponse(ctx context.Context, body UploadFileByUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileByUrlResp, error) {
	rsp, err := c.UploadFileByUrl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileByUrlResp(rsp)
}

// GetFileUrlWithResponse request returning *GetFileUrlResp
func (c *ClientWithResponses) GetFileUrlWithResponse(ctx context.Context, id FileUUIDPath, reqEditors ...RequestEditorFn) (*GetFileUrlResp, error) {
	rsp, err := c.GetFileUrl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileUrlResp(rsp)
}

// DeleteMessageWithBodyWithResponse request with arbitrary body returning *DeleteMessageResp
func (c *ClientWithResponses) DeleteMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error) {
	rsp, err := c.DeleteMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageResp(rsp)
}

func (c *ClientWithResponses) DeleteMessageWithResponse(ctx context.Context, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error) {
	rsp, err := c.DeleteMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageResp(rsp)
}

// SendMessageWithBodyWithResponse request with arbitrary body returning *SendMessageResp
func (c *ClientWithResponses) SendMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageResp, error) {
	rsp, err := c.SendMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageResp(rsp)
}

func (c *ClientWithResponses) SendMessageWithResponse(ctx context.Context, body SendMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageResp, error) {
	rsp, err := c.SendMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageResp(rsp)
}

// EditMessageWithBodyWithResponse request with arbitrary body returning *EditMessageResp
func (c *ClientWithResponses) EditMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMessageResp, error) {
	rsp, err := c.EditMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMessageResp(rsp)
}

func (c *ClientWithResponses) EditMessageWithResponse(ctx context.Context, body EditMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMessageResp, error) {
	rsp, err := c.EditMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMessageResp(rsp)
}

// AckMessageWithBodyWithResponse request with arbitrary body returning *AckMessageResp
func (c *ClientWithResponses) AckMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AckMessageResp, error) {
	rsp, err := c.AckMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAckMessageResp(rsp)
}

func (c *ClientWithResponses) AckMessageWithResponse(ctx context.Context, body AckMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*AckMessageResp, error) {
	rsp, err := c.AckMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAckMessageResp(rsp)
}

// SendHistoryMessageWithBodyWithResponse request with arbitrary body returning *SendHistoryMessageResp
func (c *ClientWithResponses) SendHistoryMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendHistoryMessageResp, error) {
	rsp, err := c.SendHistoryMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendHistoryMessageResp(rsp)
}

func (c *ClientWithResponses) SendHistoryMessageWithResponse(ctx context.Context, body SendHistoryMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendHistoryMessageResp, error) {
	rsp, err := c.SendHistoryMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendHistoryMessageResp(rsp)
}

// DeleteMessageReactionWithBodyWithResponse request with arbitrary body returning *DeleteMessageReactionResp
func (c *ClientWithResponses) DeleteMessageReactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMessageReactionResp, error) {
	rsp, err := c.DeleteMessageReactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageReactionResp(rsp)
}

func (c *ClientWithResponses) DeleteMessageReactionWithResponse(ctx context.Context, body DeleteMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMessageReactionResp, error) {
	rsp, err := c.DeleteMessageReaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageReactionResp(rsp)
}

// AddMessageReactionWithBodyWithResponse request with arbitrary body returning *AddMessageReactionResp
func (c *ClientWithResponses) AddMessageReactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMessageReactionResp, error) {
	rsp, err := c.AddMessageReactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMessageReactionResp(rsp)
}

func (c *ClientWithResponses) AddMessageReactionWithResponse(ctx context.Context, body AddMessageReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMessageReactionResp, error) {
	rsp, err := c.AddMessageReaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMessageReactionResp(rsp)
}

// MarkMessageReadWithBodyWithResponse request with arbitrary body returning *MarkMessageReadResp
func (c *ClientWithResponses) MarkMessageReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkMessageReadResp, error) {
	rsp, err := c.MarkMessageReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkMessageReadResp(rsp)
}

func (c *ClientWithResponses) MarkMessageReadWithResponse(ctx context.Context, body MarkMessageReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkMessageReadResp, error) {
	rsp, err := c.MarkMessageRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkMessageReadResp(rsp)
}

// MarkMessagesReadUntilWithBodyWithResponse request with arbitrary body returning *MarkMessagesReadUntilResp
func (c *ClientWithResponses) MarkMessagesReadUntilWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkMessagesReadUntilResp, error) {
	rsp, err := c.MarkMessagesReadUntilWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkMessagesReadUntilResp(rsp)
}

func (c *ClientWithResponses) MarkMessagesReadUntilWithResponse(ctx context.Context, body MarkMessagesReadUntilJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkMessagesReadUntilResp, error) {
	rsp, err := c.MarkMessagesReadUntil(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkMessagesReadUntilResp(rsp)
}

// RestoreMessageWithBodyWithResponse request with arbitrary body returning *RestoreMessageResp
func (c *ClientWithResponses) RestoreMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreMessageResp, error) {
	rsp, err := c.RestoreMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreMessageResp(rsp)
}

func (c *ClientWithResponses) RestoreMessageWithResponse(ctx context.Context, body RestoreMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreMessageResp, error) {
	rsp, err := c.RestoreMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreMessageResp(rsp)
}

// GetTemplatesWithResponse request returning *GetTemplatesResp
func (c *ClientWithResponses) GetTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTemplatesResp, error) {
	rsp, err := c.GetTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesResp(rsp)
}

// ParseListChannelsResp parses an HTTP response from a ListChannelsWithResponse call
func ParseListChannelsResp(rsp *http.Response) (*ListChannelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListChannelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseActivateChannelResp parses an HTTP response from a ActivateChannelWithResponse call
func ParseActivateChannelResp(rsp *http.Response) (*ActivateChannelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateChannelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivateChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ActivateChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeactivateChannelResp parses an HTTP response from a DeactivateChannelWithResponse call
func ParseDeactivateChannelResp(rsp *http.Response) (*DeactivateChannelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateChannelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeactivateChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateChannelResp parses an HTTP response from a UpdateChannelWithResponse call
func ParseUpdateChannelResp(rsp *http.Response) (*UpdateChannelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChannelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseActivateTemplateResp parses an HTTP response from a ActivateTemplateWithResponse call
func ParseActivateTemplateResp(rsp *http.Response) (*ActivateTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeactivateTemplateResp parses an HTTP response from a DeactivateTemplateWithResponse call
func ParseDeactivateTemplateResp(rsp *http.Response) (*DeactivateTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateTemplateResp parses an HTTP response from a UpdateTemplateWithResponse call
func ParseUpdateTemplateResp(rsp *http.Response) (*UpdateTemplateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTemplateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadFileResp parses an HTTP response from a UploadFileWithResponse call
func ParseUploadFileResp(rsp *http.Response) (*UploadFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadFileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadFileByUrlResp parses an HTTP response from a UploadFileByUrlWithResponse call
func ParseUploadFileByUrlResp(rsp *http.Response) (*UploadFileByUrlResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileByUrlResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadFileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFileUrlResp parses an HTTP response from a GetFileUrlWithResponse call
func ParseGetFileUrlResp(rsp *http.Response) (*GetFileUrlResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileUrlResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMessageResp parses an HTTP response from a DeleteMessageWithResponse call
func ParseDeleteMessageResp(rsp *http.Response) (*DeleteMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendMessageResp parses an HTTP response from a SendMessageWithResponse call
func ParseSendMessageResp(rsp *http.Response) (*SendMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditMessageResp parses an HTTP response from a EditMessageWithResponse call
func ParseEditMessageResp(rsp *http.Response) (*EditMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAckMessageResp parses an HTTP response from a AckMessageWithResponse call
func ParseAckMessageResp(rsp *http.Response) (*AckMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AckMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSendHistoryMessageResp parses an HTTP response from a SendHistoryMessageWithResponse call
func ParseSendHistoryMessageResp(rsp *http.Response) (*SendHistoryMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendHistoryMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMessageReactionResp parses an HTTP response from a DeleteMessageReactionWithResponse call
func ParseDeleteMessageReactionResp(rsp *http.Response) (*DeleteMessageReactionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMessageReactionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddMessageReactionResp parses an HTTP response from a AddMessageReactionWithResponse call
func ParseAddMessageReactionResp(rsp *http.Response) (*AddMessageReactionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMessageReactionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkMessageReadResp parses an HTTP response from a MarkMessageReadWithResponse call
func ParseMarkMessageReadResp(rsp *http.Response) (*MarkMessageReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkMessageReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMarkMessagesReadUntilResp parses an HTTP response from a MarkMessagesReadUntilWithResponse call
func ParseMarkMessagesReadUntilResp(rsp *http.Response) (*MarkMessagesReadUntilResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkMessagesReadUntilResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarkMessagesReadUntilResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreMessageResp parses an HTTP response from a RestoreMessageWithResponse call
func ParseRestoreMessageResp(rsp *http.Response) (*RestoreMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTemplatesResp parses an HTTP response from a GetTemplatesWithResponse call
func ParseGetTemplatesResp(rsp *http.Response) (*GetTemplatesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemplateListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
